<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
	*     Firemox is a turn based strategy simulator
	*     Copyright (C) 2003-2007 Fabrice Daugan and contributors
	*
	*     This program is free software; you can redistribute it and/or modify it
	* under the terms of the GNU General Public License as published by the Free
	* Software Foundation; either version 2 of the License, or (at your option) any
	* later version.
	*
	*     This program is distributed in the hope that it will be useful, but WITHOUT
	* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
	* FOR A PARTICULAR PURPOSE.    See the GNU General Public License for more
	* details.
	*
	*     You should have received a copy of the GNU General Public License along
	* with this program; if not, write to the Free Software Foundation, Inc.,
	* 59 Temple Place, Suite 330, Boston, MA    02111-1307    USA
	*
	* XML Schema for Firemox XML card and XML turn based strategy rules
	* definition.
	*
	* @author Fabrice Daugan
	* @author Hoani Cross
-->
<!--[[apt lang=en]]
	* References
	
	`This is the most important part of the XML file for card rules writers.
	`Identified by the element <<<\<references\>>>>, it contains a set of
	`tests, actions, abilities or attachments that can be referenced from your
	`card XML code.
	Warning : Declaration order is important, you cannot refers
	to an ability or a test that has not previously
	been declared.
-->
<!--[[apt lang=fr]]
	* Les références
	
	`C'est la partie la plus importante du fichier XML pour les développeurs
	`de règles de cartes. Identifié par l'élément <<<\<references\>>>>, il
	`contient un ensemble de tests, d'actions, d'capacités ou d'attaches qui
	`peuvent être référencées depuis votre code XML d'une carte.
	Attention : L'ordre de déclaration est important, il n'est pas possible 
	reférencer un test, capacité,... qui no'a pas été déclaré avant.
-->
<references xmlns="http://sourceforge.net/projects/firemox"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://sourceforge.net/projects/firemox ../validator.xsd">

	<!--[[apt lang=en]]
		** Tests references
		
		`These are described within the nested <<<\<tests\>>>> element. We can find
		`the following references :
		
		*___________________________+__________________________________________________+
		| <<Reference name>>        | <<Description>>
		*___________________________+__________________________________________________+-->
	<!--[[apt lang=fr]]
		** Références de test
		
		`Elles sont décrites dans l'élément <<<\<tests\>>>>. On trouvera les références
		`suivantes :
		
		*___________________________+__________________________________________________+
		| <<Nom de la référence>>   | <<Description>>
		*___________________________+__________________________________________________+-->
	<tests>

		<!--[[apt lang=en|fr @reference-name]]
			Returns true if there is an imprinted card on the current card. |
			Retourne vrai s'il y a une carte impriméee sur la carte courante. -->
		<test reference-name="has-imprinted-card">
			<has-private-object object-name="imprinted-card" target="this" />
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Returns true if there is no cards in your hand.
			| Retourne vrai si vous n'avez plus de cartes en main. -->
		<test reference-name="hellbent">
			<not>
				<has restriction-zone="hand">
					<controller player="you" card="tested" />
				</has>
			</not>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Has this "once each turn" ability not been played ?
			| Est-ce que cette capacité du type "ne peut être jouée
			qu'une seule fois par tour" a déjà été jouée ? -->
		<test reference-name="once-each-turn">
			<equal right="0">
				<left register="this" index="free0" />
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Has the tested card just been summoned ?
			| Est-ce que la carte testée viens d'être invoquée ? -->
		<test reference-name="tested-just-summoned">
			<equal left="just-summoned">
				<right>
					<and left="just-summoned">
						<right register="tested" index="state" />
					</and>
				</right>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Has the current card just been summoned ?
			| Est-ce que la carte courante vient d'être invoquée ? -->
		<test reference-name="just-summoned">
			<replace-tested by="this" ref="tested-just-summoned" />
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the current phase your attackers declaration phase ?
			| Est-ce que la phase courante est votre phase de déclaration des
			attaquants ? -->
		<test reference-name="before-attackers-declaration">
			<and>
				<phase-is phase="declare-attacking" />
				<controller player="currentplayer" card="this" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the current phase your untap phase ?
			| Est-ce que la phase courante est votre phase de dégagement ? -->
		<test reference-name="during-your-untap">
			<and>
				<phase-is phase="untap" />
				<controller player="currentplayer" card="this" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the current phase the untap phase of controller of modifier creator ?
			| Est-ce que la phase courante est la phase de dégagement du controller 
			du créateur du modifieur? -->
		<test reference-name="during-modifier-untap">
			<and>
				<phase-is phase="untap" />
				<controller player="currentplayer" card="modifier.creator" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the current phase your upkeep phase ?
			| Est-ce la phase courante est votre phase d'entretien ? -->
		<test reference-name="during-your-upkeep">
			<and>
				<phase-is phase="upkeep" />
				<controller player="currentplayer" card="this" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the current phase is an oppponent's upkeep phase ?
			| Est-ce la phase courante est la phase d'entretien d'un adversaire ? -->
		<test reference-name="during-oppponent-upkeep">
			<and>
				<phase-is phase="upkeep" />
				<not>
					<controller player="currentplayer" card="this" />
				</not>
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the current phase your draw phase ?
			| Est-ce que la phase courante est votre phase de pioche ? -->
		<test reference-name="during-your-draw">
			<and>
				<phase-is phase="draw" />
				<controller player="currentplayer" card="this" />
			</and>
		</test>

		<!--[[apt lang=en @reference-name]]
			Is the current phase your pre-combat main phase ? -->
		<test reference-name="during-your-precombat-main">
			<and>
				<phase-is phase="precombat-main" />
				<controller player="currentplayer" card="this" />
			</and>
		</test>
		
		<!--[[apt lang=en @reference-name]]
			Is the current phase one of your main phases ? -->
		<test reference-name="during-your-main">
			<and>
				<or>
					<phase-is phase="precombat-main" />
					<phase-is phase="postcombat-main" />
				</or>
				<controller player="currentplayer" card="this" />
			</and>
		</test>

		<!--[[apt lang=en @reference-name]]
			Is the current phase your combat phase ? -->
		<test reference-name="during-your-combat">
			<and>
				<phase-is phase="declare-attack" />
				<controller player="currentplayer" card="this" />
			</and>
		</test>

		<!--[[apt lang=en @reference-name]]
			Is the current phase your end of turn phase ? -->
		<test reference-name="during-your-eot">
			<and>
				<phase-is phase="eot" />
				<controller player="currentplayer" card="this" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Does the tested card controller graveyard contain at least an
			amount of cards greater or equal to the number identified by the
			<<<threshold>>> register of that card ?
			| Est-ce que le cimetière du contrôleur de la carte testée
			contient au moins un nombre de cartes supérieur ou égal au
			nombre identifié par le registre <<<threshold>>> de cette
			carte ? -->
		<test reference-name="threshold">
			<sup-equal right="threshold">
				<left>
					<counter restriction-zone="graveyard">
						<controller player="controller" card="tested" />
					</counter>
				</left>
			</sup-equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the tested card attacking ?
			| Est-ce que la carte testée est en train d'attaquer ? -->
		<test reference-name="tested-is-attacking">
			<equal left="declared-as-attacking">
				<right>
					<and left="declared-as-attacking">
						<right register="tested" index="state" />
					</and>
				</right>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the first card in the target list attacking ?
			| Est-ce que la première carte dans la liste des cibles est en
			train d'attaquer ? -->
		<test reference-name="first-target-is-attacking">
			<replace-tested by="target-list.first" ref="tested-is-attacking" />
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the current card attacking ?
			| Est-ce que la carte courante est en train d'attaquer ? -->
		<test reference-name="is-attacking">
			<replace-tested by="this" ref="tested-is-attacking" />
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the saved card attacking ?
			| Est-ce que la carte sauvegardée est en train d'attaquer ? -->
		<test reference-name="saved-is-attacking">
			<replace-tested by="saved" ref="tested-is-attacking" />
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the tested card blocking ?
			| Est-ce que la carte testée est en train de bloquer ? -->
		<test reference-name="tested-is-blocking">
			<equal left="declared-as-blocking">
				<right>
					<and left="declared-as-blocking">
						<right register="tested" index="state" />
					</and>
				</right>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the first card in the target list blocking ?
			| Est-ce que la première carte dans la liste des cibles est en
			train de bloquer ? -->
		<test reference-name="first-target-is-blocking">
			<replace-tested by="target-list.first" ref="tested-is-blocking" />
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the current card blocking ?
			| Est-ce que la carte courante est en train de bloquer ? -->
		<test reference-name="is-blocking">
			<replace-tested by="this" ref="tested-is-blocking" />
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Has the tested card been blocked ?
			| Est-ce que la carte testée a été bloquée ? -->
		<test reference-name="tested-is-blocked">
			<equal left="declared-as-blocked">
				<right>
					<and left="declared-as-blocked">
						<right register="tested" index="state" />
					</and>
				</right>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Has the current card been blocked ?
			| Est-ce que la carte courante a été bloquée ? -->
		<test reference-name="is-blocked">
			<replace-tested by="this" ref="tested-is-blocked" />
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Has the tested card been untapped manually ?
			| Est-ce que la carte testée a été dégagée manuellement ? -->
		<test reference-name="is-untapped-under-condition">
			<and>
				<in-zone zone="playANDuntapped" card="tested" />
				<not>
					<has-property property="does-not-untap" card="tested" />
				</not>
				<equal left="untapped-under-condition">
					<right>
						<and left="untapped-under-condition">
							<right register="tested" index="state" />
						</and>
					</right>
				</equal>
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Does the tested card have combat damage to assign ?
			| Est-ce que la carte testée a des dommages de combat à affliger ? -->
		<test reference-name="tested-has-combat-damage-to-assign">
			<sup right="0">
				<left register="tested" index="combat.toassign" />
			</sup>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Has the tested card not been blocked ?
			| Est-ce que la carte testée n'a  pas été bloquée ? -->
		<test reference-name="tested-is-unblocked">
			<equal left="declared-as-unblocked">
				<right>
					<and left="declared-as-unblocked">
						<right register="tested" index="state" />
					</and>
				</right>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Has the current card not been blocked ?
			| Est-ce que la carte courante n'a  pas été bloquée ? -->
		<test reference-name="is-unblocked">
			<replace-tested by="this" ref="tested-is-unblocked" />
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the tested card in combat ?
			| Est-ce que la carte testée participe au combat ? -->
		<test reference-name="tested-in-combat">
			<or>
				<test ref="tested-is-attacking" />
				<test ref="tested-is-blocking" />
			</or>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the current card in combat ?
			| Est-ce que la carte courante participe au combat ? -->
		<test reference-name="in-combat">
			<replace-tested by="this" ref="tested-in-combat" />
		</test>

		<!-- CAN I USE {T} ability      -->
		<!-- if (is in play and untapped) -->
		<!--   and (is not a creature     -->
		<!--        or has haste property -->
		<!--        or state&0x01=0x00    -->
		<!--        )                     -->
		<!--[[apt lang=en|fr @reference-name]]
			Can the current card <tap> ?
			| Est-ce que la carte courante peut <s'engager> ? -->
		<test reference-name="cantap">
			<and>
				<in-zone zone="playANDuntapped" card="this" />
				<or>
					<not>
						<has-idcard idcard="creature" card="this" />
					</not>
					<has-property property="haste" card="this" />
					<not ref="just-summoned" />
				</or>
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Can the current card use the <<<\{T\}>>> ability (in addition to the
			previous test, this one tests whether the current card is not
			affected by a limitation that doesn't allow it to <tap>) ?
			| Est-ce que la carte courante peut utiliser la capacité
			<<<\{T\}>>> (en plus du précédent test, ce test vérifie si la
			carte courante n'est pas affectée par une quelconque limitation
			qui l'empècher ? -->
		<test reference-name="can-use-T">
			<and>
				<test ref="cantap" />
				<not>
					<has-property property="cannot-use-T" />
				</not>
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is there a private card counter ?
			This counter is not visible for players.
			Also see <<<init-counter>>> ability.
			| Existe-t-il un compteur privé pour la carte courante ?
			Ce compteur n'est pas visible pour les joueurs.
			Consultez également la capacité <<<init-counter>>>. -->
		<test reference-name="has-counter">
			<sup right="0">
				<left register="this" index="0" />
			</sup>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the tested card a multicolored card (it has at least two
			colors) ?
			| Est-ce que la carte testée est multicolore (elle a au moins
			deux couleurs) ? -->
		<test reference-name="is-multicolored">
			<sup right="1">
				<left>
					<bit-count>
						<value>
							<card-colors card="tested" />
						</value>
					</bit-count>
				</left>
			</sup>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the current card a multicolored card (it has at least two
			colors) ?
			| Est-ce que la carte courante est multicolore (elle a au moins
			deux couleurs) ? -->
		<test reference-name="this-is-multicolored">
			<sup right="1">
				<left>
					<bit-count>
						<value>
							<card-colors card="this" />
						</value>
					</bit-count>
				</left>
			</sup>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the tested card a mono-colored card ?
			| Est-ce que la carte testée est monocolore ? -->
		<test reference-name="is-monocolored">
			<equal right="1">
				<left>
					<bit-count>
						<value>
							<card-colors card="tested" />
						</value>
					</bit-count>
				</left>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the current card a mono-colored card ?
			| Est-ce que la carte courante est monocolore ? -->
		<test reference-name="this-is-monocolored">
			<equal right="1">
				<left>
					<bit-count>
						<value>
							<card-colors card="this" />
						</value>
					</bit-count>
				</left>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the tested card a colored card (it has at least one color) ?
			| Est-ce que la carte testée est colorée (elle a au moins une
			couleur) ? -->
		<test reference-name="is-colored">
			<different right="0">
				<left>
					<bit-count>
						<value>
							<card-colors card="tested" />
						</value>
					</bit-count>
				</left>
			</different>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the current card a colored card (it has at least one color) ?
			| Est-ce que la carte courante est colorée (elle a au moins une
			couleur) ? -->
		<test reference-name="this-is-colored">
			<different right="0">
				<left>
					<bit-count>
						<value>
							<card-colors card="this" />
						</value>
					</bit-count>
				</left>
			</different>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the tested card target ?
			| Est-ce que la carte testée peut être ciblée ? -->
		<test reference-name="is-target">
			<and>
				<not>
					<has-property property="shroud" card="tested" />
				</not>
				<or>
					<and>
						<!-- Source is a spell -->
						<not>
							<in-zone zone="play" card="this" />
						</not>
						<not>
							<has-property property="protection-from-spells" card="tested" />
						</not>
					</and>
					<and>
						<!-- Source is an ability -->
						<in-zone zone="play" card="this" />
						<not>
							<has-property property="protection-from-abilities" card="tested" />
						</not>
					</and>
				</or>
				<or>
					<not>
						<has-property property="protection-from-all-colors" card="tested" />
					</not>
					<not>
						<test ref="this-is-colored" />
					</not>
				</or>
				<or>
					<not>
						<has-property property="protection-from-multicolored" card="tested" />
					</not>
					<not>
						<test ref="this-is-multicolored" />
					</not>
				</or>
				<or>
					<not>
						<has-property property="protection-from-monocolored" card="tested" />
					</not>
					<not>
						<test ref="this-is-monocolored" />
					</not>
				</or>
				<not>
					<has-property property="protection-from-color" card="this" color-mask="tested" />
				</not>
				<not>
					<has-property property="protection-from-idcard" card="this"
						idcard-mask="tested" />
				</not>
				<not>
					<has-property property="protection-from-property" card="this"
						property-mask="tested" />
				</not>
				<not>
					<has-property property="untargetable-by-idcard" card="this"
						idcard-mask="tested" />
				</not>
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the tested card a target land ?
			| Est-ce que la carte testée est un terrain ciblable ? -->
		<test reference-name="is-targetable-land">
			<and>
				<has-idcard idcard="land" card="tested" />
				<test ref="is-target" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the tested card a target spell ?
			| Est-ce que la carte testée est un sort ciblable ? -->
		<test reference-name="is-targetable-spell">
			<and>
				<is-spell target="tested" />
				<in-zone zone="stack" card="tested" />
				<not>
					<is-this card="tested" />
				</not>
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			This test must return <true> to design a valid damage source.
			| Ce test doit retourner <vrai> pour désigner une source de
			dommages valide. -->
		<test reference-name="valid-damage-source">
			<and>
				<not>
					<is-player target="tested" />
				</not>
				<or>
					<in-zone zone="play" card="tested" />
					<and>
						<in-zone zone="stack" card="tested" />
						<is-spell target="tested" />
					</and>
				</or>
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			This test must return <true> to design a target damage source.
			| Ce test doit retourner <vrai> pour désigner une source de
			dommages ciblable. -->
		<test reference-name="is-targetable-damage-source">
			<and>
				<test ref="valid-damage-source" />
				<test ref="is-target" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			To have an ability being targeted properly, this test must
			return <true>.
			| Afin de cibler une capacité de manière appropriée, ce test
			doit retourner <vrai>. -->
		<test reference-name="is-targetable-ability">
			<and>
				<is-ability target="tested" type="any"/>
				<in-zone zone="stack" card="tested" />
			</and>
		</test>

		<!--[[apt lang=en @reference-name]]
			To have an activated ability being targeted properly, this test must
			return <true>. -->
		<test reference-name="is-targetable-activated-ability">
			<and>
				<is-ability target="tested" type="activated"/>
				<in-zone zone="stack" card="tested" />
			</and>
		</test>
		
		<!--[[apt lang=en @reference-name]]
			To have a triggered ability being targeted properly, this test must
			return <true>. -->
		<test reference-name="is-targetable-triggered-ability">
			<and>
				<is-ability target="tested" type="triggered"/>
				<in-zone zone="stack" card="tested" />
			</and>
		</test>
		
		<!--[[apt lang=en @reference-name]]
			To have an activated or triggered ability being targeted properly, this test must
			return <true>. -->
		<test reference-name="is-targetable-activated-triggered-ability">
			<and>
				<or>
					<is-ability target="tested" type="activated"/>
					<is-ability target="tested" type="triggered"/>
				</or>
				<in-zone zone="stack" card="tested" />
			</and>
		</test>
		
		<!--[[apt lang=en|fr @reference-name]]
			To have a creature being targeted properly, this test must
			return <true>.
			| Afin de cibler une créature de manière appropriée, ce test
			doit retourner <vrai>. -->
		<test reference-name="is-targetable-creature">
			<and>
				<has-idcard idcard="creature" card="tested" />
				<test ref="is-target" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			To have an artifact being targeted properly, this test must
			return <true>.
			| Afin de cibler un artefact de manière appropriée, ce test
			doit retourner <vrai>. -->
		<test reference-name="is-targetable-artifact">
			<and>
				<has-idcard idcard="artifact" card="tested" />
				<test ref="is-target" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			To have an <tappable> permanent (creature, artifact or land)
			being targetted properly, this test must return <true>.
			| Afin de cibler un permanent <engageable> (une créature, un
			artifact ou un terrain) de manière appropriée, ce test
			doit retourner <vrai>. -->
		<test reference-name="is-targetable-tappable">
			<and>
				<in-zone zone="play" card="tested" />
				<or>
					<has-idcard idcard="creature" card="tested" />
					<has-idcard idcard="artifact" card="tested" />
					<has-idcard idcard="land" card="tested" />
				</or>
				<test ref="is-target" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the tested card a basic land ?
			| Est-ce que la carte testée est un terrain basique ? -->
		<test reference-name="is-basic-land">
			<and>
				<has-idcard idcard="land" card="tested" />
				<has-property property="basic-land" card="tested" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Is the tested card a non-basic land ?
			| Est-ce que la carte testée est un terrain non-basique ? -->
		<test reference-name="is-nonbasic-land">
			<and>
				<has-idcard idcard="land" card="tested" />
				<not>
					<has-property property="basic-land" card="tested" />
				</not>
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test used to apply restrictions on the use of mana that can only
			be used to pay artifact spells mana cost
			(<Mishra's Workshop> for example).
			| Test utilisé pour appliquer des restrictions sur l'utilisation
			de mana uniquement destiné à être utilisé pour payer le coût de
			mana d'artefacts (voir <Mishra's Workshop> par exemple). -->
		<test reference-name="only-for-artifact-spell">
			<and>
				<in-zone zone="hand" card="tested" />
				<has-idcard idcard="artifact" card="tested" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test used to apply restrictions on the use of mana that can only
			be used to pay multicolored spells mana cost.
			| Test utilisé pour appliquer des restrictions sur l'utilisation
			de mana uniquement destiné à être utilisé pour payer le coût de
			mana de sorts multicolores. -->
		<test reference-name="only-for-colored-spell">
			<sup right="1">
				<left>
					<card-colors card="tested" />
				</left>
			</sup>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test used to apply restrictions on the use of mana that can only
			be used to pay cumulative upkeep mana costs.
			(<Mishra's Workshop> for example).
			| Test utilisé pour appliquer des restrictions sur l'utilisation
			de mana uniquement destiné à être utilisé pour payer le coût de
			mana d'entretiens cumulatifs. -->
		<test reference-name="only-for-cumulative-upkeep">
			<ability-is name="cumulative-upkeep" />
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			To be chosen to block the current attacking, the tested card
			must verify that this test returns <true>.
			| Pour être désigné comme bloqueur de l'attaquant courant, la
			carte testée doit vérifier que ce test retourne <vrai>. -->
		<test reference-name="valid-block">
			<and>
				<not>
					<has-property property="unblockable" card="target-list.last" />
				</not>
				<not>
					<has-property property="protection-from-color" card="tested"
						color-mask="target-list.last" />
				</not>
				<not>
					<has-property property="protection-from-idcard" card="tested"
						idcard-mask="target-list.last" />
				</not>
				<not>
					<has-property property="protection-from-property" card="tested"
						property-mask="target-list.last" />
				</not>
				<not>
					<has-property property="cannot-block" card="tested" />
				</not>
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			To have a player being targeted properly, this test must return
			<true>.
			| Pour cibler un joueur de manière appropriée, ce test doit
			retourner <vrai>. -->
		<test reference-name="is-targetable-player">
			<!-- TODO add untargetable,... properties to player -->
			<true />
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			To have a <dealtable> (creature of player) being targeted
			properly, this test must return <true>.
			| Pour cibler une créature ou un joueur de manière appropriée, ce
			test doit retourner <vrai>. -->
		<test reference-name="is-targetable-dealtable">
			<or>
				<and>
					<is-player target="tested" />
					<test ref="is-targetable-player" />
				</and>
				<and>
					<not>
						<is-player target="tested" />
					</not>
					<in-zone zone="play" card="tested" />
					<test ref="is-targetable-creature" />
				</and>
			</or>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			To have an artifact creature being targeted
			properly, this test must return <true>.
			| Pour cibler une créature artefact de manière appropriée, ce
			test doit retourner <vrai>. -->
		<test reference-name="is-targetable-artifact-creature">
			<and>
				<in-zone zone="play" card="tested" />
				<has-idcard idcard="artifact-creature" card="tested"/>
				<test ref="is-target" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			To have an enchantment being targeted properly, this test must
			return <true>.
			| Pour cibler un enchantement de manière appropriée, ce test doit
			retourner <vrai>. -->
		<test reference-name="is-targetable-enchantment">
			<and>
				<in-zone zone="play" card="tested" />
				<has-idcard idcard="enchantment" card="tested" />
				<test ref="is-target" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			To have an <aura> being targeted properly, this test must
			return <true>.
			| Pour cibler une <aura> de manière appropriée, ce test doit
			retourner <vrai>. -->
		<test reference-name="is-targetable-local-enchantment">
			<and>
				<in-zone zone="play" card="tested" />
				<has-idcard idcard="local-enchantment" card="tested" />
				<test ref="is-target" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Can the tested card attack ?
			| Est-ce que la carte testée peut attaquer ? -->
		<test reference-name="can-attack">
			<and>
				<controller player="currentplayer" card="tested" />
				<in-zone zone="playANDuntapped" card="tested" />
				<has-idcard idcard="creature" card="tested" />
				<or>
					<not>
						<has-property property="wall" card="tested" />
					</not>
					<has-property property="wall-can-attack" card="tested" />
				</or>
				<not>
					<has-property property="defender" card="tested" />
				</not>
				<not ref="tested-is-attacking" />
				<or>
					<not ref="tested-just-summoned" />
					<has-property property="haste" card="tested" />
				</or>
				<not>
					<has-property property="cannot-attack" card="tested" />
				</not>
			</and>
		</test>

		<!-- STATE-BASED :
			this test must be always true for a 'enchant ...'
			420.5d An Aura that enchants an illegal or nonexistent permanent
			is put into its owner's graveyard.
			420.5d A local enchantment that enchants an illegal or nonexistent
			permanent is put into its owner's graveyard. '
		-->
		<!--[[apt lang=en|fr @reference-name]]
			Test used for the attachment of an <aura> to the enchanted
			permanent.
			| Test utilisé pour l'attache d'une <aura> à un permanent
			enchanté. -->
		<test reference-name="valid-enchant">
			<in-zone zone="play" card="tested" />
		</test>

		<!-- STATE-BASED :
			this test must be always true for a 'enchant land'
			420.5d An Aura that enchants an illegal or nonexistent permanent
			is put into its owner's graveyard.
			420.5d A local enchantment that enchants an illegal or nonexistent
			permanent is put into its owner's graveyard. '
		-->
		<!--[[apt lang=en|fr @reference-name]]
			Test used for the attachment of an <aura> to the enchanted
			land.
			| Test utilisé pour l'attache d'une <aura> à un terrain
			enchanté. -->
		<test reference-name="valid-enchant-land">
			<and>
				<test ref="valid-enchant" />
				<has-idcard idcard="land" card="tested" />
			</and>
		</test>

		<!-- STATE-BASED :
			this test must be always true for a 'enchant creature'
			420.5d An Aura that enchants an illegal or nonexistent permanent
			is put into its owner's graveyard.
			420.5d A local enchantment that enchants an illegal or nonexistent
			permanent is put into its owner's graveyard. '
		-->
		<!--[[apt lang=en|fr @reference-name]]
			Test used for the attachment of an <aura> to the enchanted
			creature.
			| Test utilisé pour l'attache d'une <aura> à une créature
			enchantée. -->
		<test reference-name="valid-enchant-creature">
			<and>
				<test ref="valid-enchant" />
				<has-idcard idcard="creature" card="tested" />
			</and>
		</test>

		<!-- STATE-BASED :
			this test must be always true for a 'enchant artifact creature'
			420.5d An Aura that enchants an illegal or nonexistent permanent
			is put into its owner's graveyard.
			420.5d A local enchantment that enchants an illegal or nonexistent
			permanent is put into its owner's graveyard. '
		-->
		<!--[[apt lang=en|fr @reference-name]]
			Test used for the attachment of an <aura> to the enchanted
			artifact creature.
			| Test utilisé pour l'attache d'une <aura> à une créature artefact
			enchantée. -->
		<test reference-name="valid-enchant-enchantment">
			<and>
				<test ref="valid-enchant" />
				<has-idcard idcard="enchantment" card="tested" />
			</and>
		</test>

		<!-- STATE-BASED :
			this test must be always true for a 'enchant artifact creature'
			420.5d An Aura that enchants an illegal or nonexistent permanent
			is put into its owner's graveyard.
			420.5d A local enchantment that enchants an illegal or nonexistent
			permanent is put into its owner's graveyard. '
		-->
		<!--[[apt lang=en|fr @reference-name]]
			Test used for the attachment of an <aura> to the enchanted
			artifact creature.
			| Test utilisé pour l'attache d'une <aura> à une créature artefact
			enchantée. -->
		<test reference-name="valid-enchant-artifact-creature">
			<and>
				<test ref="valid-enchant" />
				<has-idcard idcard="artifact-creature" card="tested" />
			</and>
		</test>

		<!-- STATE-BASED :
			this test must be always true for a 'enchant artifact'
			420.5d An Aura that enchants an illegal or nonexistent permanent
			is put into its owner's graveyard.
			420.5d A local enchantment that enchants an illegal or nonexistent
			permanent is put into its owner's graveyard. '
		-->
		<!--[[apt lang=en|fr @reference-name]]
			Test used for the attachment of an <aura> to the enchanted
			artefact.
			| Test utilisé pour l'attache d'une <aura> à un artefact
			enchanté. -->
		<test reference-name="valid-enchant-artifact">
			<and>
				<test ref="valid-enchant" />
				<has-idcard idcard="artifact" card="tested" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test used for the attachment of an <equipment> to the equipped
			creature.
			| Test utilisé pour l'attache d'un <equipement> à une créature
			équipée. -->
		<test reference-name="valid-equip-creature">
			<and>
				<test ref="valid-enchant" />
				<has-idcard idcard="creature" card="tested" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Internal test used to select a valid card to enchant (do not use
			this directly).
			| Test interne utilisé pour sélectionner une carte valide à
			enchanter (n'utilisez pas ce test directement). -->
		<test reference-name="valid-to-enchant">
			<and>
				<in-zone zone="play" card="tested" />
				<not>
					<has-property property="cannot-be-enchanted" card="tested" />
				</not>
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test used to select a valid creature to enchant.
			| Test utilisé pour sélectionner une créature valide à enchanter. -->
		<test reference-name="valid-creature-to-enchant">
			<and>
				<test ref="valid-to-enchant" />
				<test ref="is-targetable-creature" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test used to select a valid enchantment to enchant.
			| Test utilisé pour sélectionner un enchantement valide à enchanter. -->
		<test reference-name="valid-enchantment-to-enchant">
			<and>
				<test ref="valid-to-enchant" />
				<test ref="is-targetable-enchantment" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test used to select a valid land to enchant.
			| Test utilisé pour sélectionner un terrain valide à enchanter. -->
		<test reference-name="valid-land-to-enchant">
			<and>
				<test ref="valid-to-enchant" />
				<test ref="is-targetable-land" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test used to select a valid permanent to enchant.
			| Test utilisé pour sélectionner un permanent valide à enchanter. -->
		<test reference-name="valid-permanent-to-enchant">
			<and>
				<test ref="valid-to-enchant" />
				<test ref="is-target" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test used to select a valid artifact creature to enchant.
			| Test utilisé pour sélectionner une créature artefact valide à enchanter. -->
		<test reference-name="valid-artifact-creature-to-enchant">
			<and>
				<test ref="valid-to-enchant" />
				<test ref="is-targetable-artifact-creature" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test used to select a valid artifact to enchant.
			| Test utilisé pour sélectionner un artefact valide à enchanter. -->
		<test reference-name="valid-artifact-to-enchant">
			<and>
				<test ref="valid-to-enchant" />
				<has-idcard idcard="artifact" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Internal test used check the equip stills valid (do not use
			this directly).
			| Test utilisé pour vérifier la validité d'un équipement
			(n'utilisez pas directement ce test). -->
		<test reference-name="valid-to-equip">
			<in-zone zone="play" card="tested" />
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Internal test used check the equip stills valid for the equiped 
			creature.
			| Test utilisé pour vérifier la validité de l'équipement sur la créature. 
		-->
		<test reference-name="valid-creature-to-equip">
			<and>
				<test ref="valid-to-equip" />
				<has-idcard idcard="creature" card="tested" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Internal test used to select a valid card to equip (do not use
			this directly).
			| Test utilisé pour sélectionner une carte valide à équipper
			(n'utilisez pas directement ce test). -->
		<test reference-name="valid-equip">
			<in-zone zone="play" card="attachedto" />
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test used to select a valid creature to equip.
			| Test utilisé pour sélectionner une créature valide à équipper. -->
		<test reference-name="valid-equip-creature">
			<and>
				<test ref="valid-equip" />
				<not>
					<has-idcard idcard="creature" card="this" />
				</not>
				<has-idcard idcard="creature" card="attachedto" />
			</and>
		</test>

		<!-- This test is used by "update-toughness" and "update-damage" abilities -->
		<!--[[apt lang=en|fr @reference-name]]
			This test is used by <<<update-toughness>>> and
			<<<update-damage>>> abilities.
			| Ce test est utilisé par les capacités <<<update-toughness>>> et
			<<<update-damage>>>. -->
		<test reference-name="died-card">
			<and>
				<in-zone zone="play" card="context.card" />
				<or>
					<and>
						<has-idcard idcard="creature" card="context.card" />
						<inf-equal>
							<left register="context.card" index="toughness" />
							<right register="context.card" index="damage" />
						</inf-equal>
					</and>
					<and>
						<not>
							<has-idcard idcard="creature" card="context.card" />
						</not>
						<different left="0">
							<right register="context.card" index="damage" />
						</different>
					</and>
				</or>
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test only used by combat-damage assignments ability to check the creatures 
			blocking the super.tested card.
			| Test uniquement utilisé par la capacité d'assignation de dégats de 
			combat pour vérifier les créatures bloquant la carte super.tested. 
		-->
		<test reference-name="priv_blocking-tested-counter">
			<and>
				<test ref="tested-is-blocking" />
				<target-list operation="contains" target="tested">
					<list-index>
						<add left="1">
							<right>
								<target-list operation="index-of-saved-list"
									target="super.tested">
									<list-index register="stack" index="1" />
								</target-list>
							</right>
						</add>
					</list-index>
				</target-list>
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test only used by combat-damage assignments ability to check the creatures 
			blocked by the super.tested card.
			| Test uniquement utilisé par la capacité d'assignation de dégats de 
			combat pour vérifier les créatures bloquées par la carte super.tested. 
		-->
		<test reference-name="priv_blocked-by-tested-counter">
			<and>
				<test ref="tested-is-attacking" />
				<target-list operation="contains" target="super.tested">
					<list-index>
						<add left="1">
							<right>
								<target-list operation="index-of-saved-list" target="tested">
									<list-index register="stack" index="1" />
								</target-list>
							</right>
						</add>
					</list-index>
				</target-list>
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test used during the discard phase to verify if the current
			player has to discard cards from his hand.
			| Test utilisé durant la phase de défausse pour vérifier si le
			joueur courant a des cartes en trop à défausser dans sa main. -->
		<test reference-name="priv_currentplayer-has-to-discard">
			<sup>
				<left>
					<counter restriction-zone="hand">
						<controller player="currentplayer" />
					</counter>
				</left>
				<right register="currentplayer" index="maxi-cards-in-hand" />
			</sup>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Has the <flashback> been used ?
			| Est-ce que le <flashback> a été utilisé ? -->
		<test reference-name="flashback-used">
			<equal left="flashback-used">
				<right>
					<and left="flashback-used">
						<right register="tested" index="special-abilities" />
					</and>
				</right>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Has the <buyback> been paid for this spell ?
			| Est-ce que le <buyback> a été payé pour ce sort ? -->
		<test reference-name="buyback-used">
			<equal left="buyback-used">
				<right>
					<and left="buyback-used">
						<right register="tested" index="special-abilities" />
					</and>
				</right>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Has the <kicker> been paid for this spell ?
			| Est-ce que le <kick> a été payé pour ce sort ? -->
		<test reference-name="kicker-used">
			<equal left="kicker-used">
				<right>
					<and left="kicker-used">
						<right register="tested" index="special-abilities" />
					</and>
				</right>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Has the second <kicker> been paid for this spell ?
			| Est-ce que le second <kick> a été payé pour ce sort ? -->
		<test reference-name="kicker2-used">
			<equal left="kicker2-used">
				<right>
					<and left="kicker2-used">
						<right register="tested" index="special-abilities" />
					</and>
				</right>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Has the <entwine> been paid for this spell ?
			| Est-ce que le <entwine> a été payé pour ce sort ? -->
		<test reference-name="entwine-used">
			<equal left="entwine-used">
				<right>
					<and left="entwine-used">
						<right register="tested" index="special-abilities" />
					</and>
				</right>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Returns <true> if the current card has no more <fading> counter
			on it.
			| Retourne <vrai> si la carte courante n'a plus de marqueur
			<fading> sur elle. -->
		<test reference-name="has-no-more-fading">
			<equal right="0">
				<left>
					<counter object-name="fade" card="this" />
				</left>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Returns <true> if the current card has no more <time> counter
			on it.
			| Retourne <vrai> si la carte courante n'a plus de marqueur
			<time> sur elle. -->
		<test reference-name="has-no-more-time">
			<equal right="0">
				<left>
					<counter object-name="time" card="this" />
				</left>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Can the creature generate ? This test cannot be used in event test.
			| Est-ce que la créture peut régénérer ? Ce test ne peut être
			référencé depuis un test d'événement. -->
		<test reference-name="can-regenerate">
			<equal right="0">
				<left>
					<and left="damage-cannot-be-regenerated" right="context.int2" />
				</left>
			</equal>
		</test>

		<!--[[apt lang=en|fr @reference-name]] ? | ? -->
		<test reference-name="is-valid-blocking-creature-for-targeted-attacking">
			<and>
				<controller player="currentplayer.opponent" card="tested" />
				<has-idcard idcard="creature" card="tested" />
				<in-zone zone="playANDuntapped" card="tested" />
				<not ref="tested-is-blocking" />
				<or>
					<not>
						<has-idcard idcard="artifact-creature" card="tested" />
					</not>
					<not>
						<has-property property="cannot-be-blocked-by-artifacts"
							card="target-list.last" />
					</not>
				</or>
				<or>
					<not>
						<has-property property="wall" card="tested" />
					</not>
					<not>
						<has-property property="cannot-be-blocked-by-walls" card="target-list.last" />
					</not>
				</or>
				<or>
					<has-property property="flying" card="tested" />
					<has-property property="reach" card="tested" />
					<not>
						<has-property property="flying" card="target-list.last" />
					</not>
				</or>
				<or>
					<not>
						<has-property property="block-only-flying" card="tested" />
					</not>
					<has-property property="flying" card="target-list.last" />
				</or>
				<or>
					<and>
						<has-property property="shadow" card="target-list.last" />
						<or>
							<has-property property="shadow" card="tested" />
							<has-property property="block-as-shadow" card="tested" />
						</or>
					</and>
					<and>
						<not>
							<has-property property="shadow" card="target-list.last" />
						</not>
						<not>
							<has-property property="shadow" card="tested" />
						</not>
					</and>
				</or>
				<or>
					<not>
						<has-property property="horsemanship" card="target-list.last" />
					</not>
					<has-property property="horsemanship" card="tested" />
				</or>
				<or>
					<not>
						<has-property property="fear" card="target-list.last" />
					</not>
					<and>
						<has-property property="fear" card="target-list.last" />
						<or>
							<has-idcard idcard="artifact" card="tested" />
							<has-color color="black" card="tested" />
						</or>
					</and>
				</or>
				<or>
					<not>
						<has-property property="snow-forestwalk" card="target-list.last" />
					</not>
					<and>
						<has-property property="snow-forestwalk" card="target-list.last" />
						<not>
							<has restriction-zone="play">
								<and>
									<controller player="currentplayer.opponent" card="tested" />
									<has-idcard idcard="forest" card="tested" />
									<has-property property="snow" card="tested" />
								</and>
							</has>
						</not>
					</and>
				</or>
				<or>
					<not>
						<has-property property="snow-swampwalk" card="target-list.last" />
					</not>
					<and>
						<has-property property="snow-swampwalk" card="target-list.last" />
						<not>
							<has restriction-zone="play">
								<and>
									<controller player="currentplayer.opponent" card="tested" />
									<has-idcard idcard="swamp" card="tested" />
									<has-property property="snow" card="tested" />
								</and>
							</has>
						</not>
					</and>
				</or>
				<or>
					<not>
						<has-property property="snow-plainswalk" card="target-list.last" />
					</not>
					<and>
						<has-property property="snow-plainswalk" card="target-list.last" />
						<not>
							<has restriction-zone="play">
								<and>
									<controller player="currentplayer.opponent" card="tested" />
									<has-idcard idcard="plains" card="tested" />
									<has-property property="snow" card="tested" />
								</and>
							</has>
						</not>
					</and>
				</or>
				<or>
					<not>
						<has-property property="snow-mountainwalk" card="target-list.last" />
					</not>
					<and>
						<has-property property="snow-mountainwalk" card="target-list.last" />
						<not>
							<has restriction-zone="play">
								<and>
									<controller player="currentplayer.opponent" card="tested" />
									<has-idcard idcard="mountain" card="tested" />
									<has-property property="snow" card="tested" />
								</and>
							</has>
						</not>
					</and>
				</or>
				<or>
					<not>
						<has-property property="nonbasic-landwalk" card="target-list.last" />
					</not>
					<and>
						<has-property property="nonbasic-landwalk" card="target-list.last" />
						<not>
							<has restriction-zone="play">
								<and>
									<controller player="currentplayer.opponent" card="tested" />
									<test ref="is-nonbasic-land" />
								</and>
							</has>
						</not>
					</and>
				</or>
				<or>
					<not>
						<has-property property="legendary-landwalk" card="target-list.last" />
					</not>
					<and>
						<has-property property="legendary-landwalk" card="target-list.last" />
						<not>
							<has restriction-zone="play">
								<and>
									<controller player="currentplayer.opponent" card="tested" />
									<has-property property="legend" />
								</and>
							</has>
						</not>
					</and>
				</or>
				<or>
					<not>
						<has-property property="snow-islandwalk" card="target-list.last" />
					</not>
					<and>
						<has-property property="snow-islandwalk" card="target-list.last" />
						<not>
							<has restriction-zone="play">
								<and>
									<controller player="currentplayer.opponent" card="tested" />
									<has-idcard idcard="island" card="tested" />
									<has-property property="snow" card="tested" />
								</and>
							</has>
						</not>
					</and>
				</or>
				<or>
					<not>
						<has-property property="islandwalk" card="target-list.last" />
					</not>
					<and>
						<has-property property="islandwalk" card="target-list.last" />
						<not>
							<has restriction-zone="play">
								<and>
									<controller player="currentplayer.opponent" card="tested" />
									<has-idcard idcard="island" card="tested" />
								</and>
							</has>
						</not>
					</and>
				</or>
				<or>
					<not>
						<has-property property="plainswalk" card="target-list.last" />
					</not>
					<and>
						<has-property property="plainswalk" card="target-list.last" />
						<not>
							<has restriction-zone="play">
								<and>
									<controller player="currentplayer.opponent" card="tested" />
									<has-idcard idcard="plains" card="tested" />
								</and>
							</has>
						</not>
					</and>
				</or>
				<or>
					<not>
						<has-property property="mountainwalk" card="target-list.last" />
					</not>
					<and>
						<has-property property="mountainwalk" card="target-list.last" />
						<not>
							<has restriction-zone="play">
								<and>
									<controller player="currentplayer.opponent" card="tested" />
									<has-idcard idcard="mountain" card="tested" />
								</and>
							</has>
						</not>
					</and>
				</or>
				<or>
					<not>
						<has-property property="forestwalk" card="target-list.last" />
					</not>
					<and>
						<has-property property="forestwalk" card="target-list.last" />
						<not>
							<has restriction-zone="play">
								<and>
									<controller player="currentplayer.opponent" card="tested" />
									<has-idcard idcard="forest" card="tested" />
								</and>
							</has>
						</not>
					</and>
				</or>
				<or>
					<not>
						<has-property property="swampwalk" card="target-list.last" />
					</not>
					<and>
						<has-property property="swampwalk" card="target-list.last" />
						<not>
							<has restriction-zone="play">
								<and>
									<controller player="currentplayer.opponent" card="tested" />
									<has-idcard idcard="swamp" card="tested" />
								</and>
							</has>
						</not>
					</and>
				</or>
				<test ref="valid-block" />
			</and>
		</test>

		<!--[[apt lang=en|fr @reference-name]] ? | ? -->
		<test reference-name="has-at-least-one-valid-blocking-creature">
			<has restriction-zone="play">
				<and>
					<controller player="currentplayer.opponent" card="tested" />
					<has-idcard idcard="creature" card="tested" />
					<in-zone zone="playANDuntapped" card="tested" />
					<not ref="tested-is-blocking" />
				</and>
			</has>
		</test>

		<!--[[apt lang=en|fr @reference-name]]
			Test used to select a proper target for an <equipment>.
			| Test utilisé pour sélectionner une cible appropriée pour un
			<équipement>. -->
		<test reference-name="valid-creature-equip">
			<and>
				<controller player="you" card="tested" />
				<test ref="is-targetable-creature" />
				<!--  212.2i (...) An Equipment can't equip itself (...) -->
				<not>
					<is-this />
				</not>
			</and>
		</test>
	</tests>

	<!--[[apt lang=en]]
		** Actions references
		
		`These are described within the nested <<<\<actions\>>>> element. Some reference
		`are <<MACRO(\[value\],\[test\])>>, which means that you can dynamically append
		`a test to the referenced action or pass a value to the referenced action (if
		`<<value>> is specified in the parenthesis just after <<MACRO>>). We can find
		`the following references :
		
		*___________________________+__________________________________________________+
		| <<Reference name>>        | <<Description>>
		*___________________________+__________________________________________________+-->
	<!--[[apt lang=fr]]
		** Les références d'actions
		
		`Elles sont décrites au sein de l'élément <<<\<actions\>>>>. Certaines références
		`sont désignées comme des <<MACRO(\[value\],\[test\])>>, ce qui signifie que vous
		`pouvez y associer dynamiquement un test additionnel à ajouter au tests de
		`l'action ou passer une valeur à l'action référencée. On peut trouver les références
		`suivantes :
		
		*___________________________+__________________________________________________+
		| <<Nom de la référence>>   | <<Description>>
		*___________________________+__________________________________________________+-->

	<actions>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(counter-test)>> : Affinity for <<counter-test>>.
			Example : {{{mtg/cards/Dross\_Golem.html}Dross Golem}}
			| <<MACRO(counter-test)>> : Affinité pour <<counter-test>>.
			Exemple : {{{mtg/cards/Dross\_Golem.html}Dross Golem}} -->
		<action reference-name="affinity">
			<modify-register register="required-mana" operation="minus" index="colorless"
				name="affinity">
				<value>
					<counter restriction-zone="play" />
				</value>
			</modify-register>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Phase out the cards of target list.
			| Les cartes dans la liste des cibles phasent out. -->
		<action reference-name="phase-out">
			<move-card destination="phased-out" controller="you" silent="true" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Counters the spell(s) in the target list.
			| Contre les sort(s) dans la liste des cibles. -->
		<action reference-name="counter">
			<abort name="counter" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Marks the ability that referenced this action as <already been
			used this turn>.
			| Marque la capacité qui référence cette action comme étant
			<déjà jouée ce tour-ci>. -->
		<action reference-name="use-once-each-turn">
			<modify-register register="this" index="free0" operation="set" value="1" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid permanent to enchant.
			| <<MACRO(test)>> : elle vous permet de cibler un permanent valide à enchanter. -->
		<action reference-name="target-permanent-enchant">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="valid-permanent-to-enchant" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : targets all the creatures in play.
			| <<MACRO(test)>> : cible toutes les créatures en jeu. -->
		<action reference-name="all-creatures">
			<target type="card" mode="all" restriction-zone="play">
				<test>
					<has-idcard idcard="creature" />
				</test>
			</target>
		</action>

		<!--[[apt lang=en @reference-name]]
			<<MACRO(test)>> : targets all creatures in play that you control.
		-->
		<action reference-name="creatures-you-control">
			<target type="card" mode="all" restriction-zone="play">
				<test>
					<and>
						<has-idcard idcard="creature" />
						<controller player="you" />
					</and>
				</test>
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : targets all the lands in play.
			| <<MACRO(test)>> : cible toutes les terrains en jeu. -->
		<action reference-name="all-lands">
			<target type="card" mode="all" restriction-zone="play">
				<test>
					<has-idcard idcard="land" />
				</test>
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : targets all the artifacts in play.
			| <<MACRO(test)>> : cible toutes les artefactes en jeu. -->
		<action reference-name="all-artifacts">
			<target type="card" mode="all" restriction-zone="play">
				<test>
					<has-idcard idcard="artifact" />
				</test>
			</target>
		</action>
		
		<!--[[apt lang=en @reference-name]]
			<<MACRO(test)>> : targets all the enchantments in play.-->
		<action reference-name="all-enchantments">
			<target type="card" mode="all" restriction-zone="play">
				<test>
					<has-idcard idcard="enchantment" />
				</test>
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid permanent to
			have the current card to be attached to this target (works for
			<equipments> and <auras>).
			| <<MACRO(test)>> : elle vous permet de cibler un permanent valide
			de manière à ce que la carte courante s'attache à ce permanent
			ciblé (fonctionne pour les <équipements> et les <auras>). -->
		<action reference-name="target-for-attachment">
			<target type="card" mode="choose" restriction-zone="play">
				<test>
					<valid-target-attachment from="this" card="tested" />
				</test>
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid creature to enchant.
			| <<MACRO(test)>> : elle vous permet de cibler une créature valide
			à enchanter. -->
		<action reference-name="target-creature-enchant">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="valid-creature-to-enchant" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid land to enchant.
			| <<MACRO(test)>> : elle vous permet de cibler un terrain valide
			à enchanter. -->
		<action reference-name="target-land-enchant">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="valid-land-to-enchant" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid artifact to enchant.
			| <<MACRO(test)>> : elle vous permet de cibler un artefact valide
			à enchanter. -->
		<action reference-name="target-artifact-enchant">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="valid-artifact-to-enchant" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid damage source.
			| <<MACRO(test)>> : elle vous permet de cibler une source de
			dommages valide. -->
		<action reference-name="target-damage-source">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="is-targetable-damage-source" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid <aura> in play.
			| <<MACRO(test)>> : elle vous permet de cibler une <aura> valide
			en jeu. -->
		<action reference-name="target-local-enchantment">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="is-targetable-local-enchantment" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid enchantment in play.
			| <<MACRO(test)>> : elle vous permet de cibler un enchantement valide
			en jeu. -->
		<action reference-name="target-enchantment">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="is-targetable-enchantment" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid land in play.
			| <<MACRO(test)>> : elle vous permet de cibler un terrain valide
			en jeu. -->
		<action reference-name="target-land">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="is-targetable-land" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid creature in play.
			| <<MACRO(test)>> : elle vous permet de cibler une créature valide
			en jeu. -->
		<action reference-name="target-creature">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="is-targetable-creature" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid artifact in play.
			| <<MACRO(test)>> : elle vous permet de cibler un artefact valide
			en jeu. -->
		<action reference-name="target-artifact">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="is-targetable-artifact" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid artifact creature
			in play.
			| <<MACRO(test)>> : elle vous permet de cibler une créature artefact
			valide en jeu. -->
		<action reference-name="target-artifact-creature">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="is-targetable-artifact-creature" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid permanent.
			| <<MACRO(test)>> : elle vous permet de cibler un permanent valide. -->
		<action reference-name="target-permanent">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="is-target" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid non-creature
			artifact in play.
			| <<MACRO(test)>> : elle vous permet de cibler un artefact
			non-créature valide en jeu. -->
		<action reference-name="target-noncreature-artifact">
			<target type="card" mode="choose" restriction-zone="play">
				<test>
					<and>
						<has-idcard idcard="artifact" />
						<not>
							<has-idcard idcard="creature" />
						</not>
						<test ref="is-target" />
					</and>
				</test>
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid non-artifact
			creature in play.
			| <<MACRO(test)>> : elle vous permet de cibler une créature
			non-artefact valide en jeu. -->
		<action reference-name="target-nonartifact-creature">
			<target type="card" mode="choose" restriction-zone="play">
				<test>
					<and>
						<has-idcard idcard="creature" />
						<not>
							<has-idcard idcard="artifact" />
						</not>
						<test ref="is-target" />
					</and>
				</test>
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid permanent that can
			be <tapped>.
			| <<MACRO(test)>> : elle vous permet de cibler un permanent valide
			qui a la possibilité d'être <engagé>. -->
		<action reference-name="target-tappable">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="is-targetable-tappable" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid player.
			| <<MACRO(test)>> : elle vous permet de cibler joueur valide. -->
		<action reference-name="target-player">
			<target type="player" mode="choose">
				<test ref="is-targetable-player" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to choose a player (no target action).
			| <<MACRO(test)>> : elle vous permet de choisir joueur valide (pas une action de cible). -->
		<action reference-name="choose-player">
			<target type="player" mode="choose" raise-event="false">
				<test ref="is-targetable-player" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid opponent.
			| <<MACRO(test)>> : elle vous permet de cibler un adversaire valide. -->
		<action reference-name="target-opponent">
			<target type="player" mode="choose">
				<test>
					<and>
						<is-this player="opponent" />
						<test ref="is-targetable-player" />
					</and>
				</test>
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid <dealtable>
			(which is either a player or a permanent that can be dealt damage).
			| <<MACRO(test)>> : elle vous permet de cibler un <dealtable>
			valide (qui désigne un joueur ou permanent qui peut subir des
			dommages). -->
		<action reference-name="target-dealtable">
			<target type="dealtable" mode="choose" restriction-zone="play">
				<test ref="is-targetable-dealtable" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid card in play
			(equivalent to <target-permanent>).
			| <<MACRO(test)>> : elle vous permet de cibler une carte valide
			en jeu (équivalent à <target-permanent>). -->
		<action reference-name="target-card">
			<target type="card" mode="choose" restriction-zone="play">
				<test ref="is-target" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid spell in the stack.
			| <<MACRO(test)>> : elle vous permet de cibler un sort valide dans
			la pile. -->
		<action reference-name="target-spell">
			<target type="card" mode="choose" restriction-zone="stack">
				<test ref="is-targetable-spell" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to target a valid ability
			in the stack.
			| <<MACRO(test)>> : elle vous permet de cibler un capactié
			valide dans la pile. -->
		<action reference-name="target-ability">
			<target type="card" mode="choose" restriction-zone="stack">
				<test ref="is-targetable-ability" />
			</target>
		</action>

		<!--[[apt lang=en @reference-name]]
			<<MACRO(test)>> : allows you to target a valid activated ability
			in the stack.-->
		<action reference-name="target-activated-ability">
			<target type="card" mode="choose" restriction-zone="stack">
				<test ref="is-targetable-activated-ability" />
			</target>
		</action>

		<!--[[apt lang=en @reference-name]]
			<<MACRO(test)>> : allows you to target a valid triggered ability
			in the stack.-->
		<action reference-name="target-triggered-ability">
			<target type="card" mode="choose" restriction-zone="stack">
				<test ref="is-targetable-triggered-ability" />
			</target>
		</action>

		<!--[[apt lang=en @reference-name]]
			<<MACRO(test)>> : allows you to target a valid activated or triggered ability
			in the stack.-->
		<action reference-name="target-activated-triggered-ability">
			<target type="card" mode="choose" restriction-zone="stack">
				<test ref="is-targetable-activated-triggered-ability" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : allows the player in the first position
			of the target list to search within his library up to <<value>>
			cards (he can cancel the operation).
			| <<MACRO(value,test)>> : elle permet au joueur en première position
			dans la liste des cibles de chercher dans sa bibliothèque
			jusqu'à <<value>> cartes (il peut annuler l'opération). -->
		<action reference-name="search-lib-up-to-player">
			<show-zone zone="library" for="you" name="%" />
			<repeat /><!-- value ? -->
			<target mode="choose" type="card" raise-event="false" restriction-zone="library" hop="1"
				name="search-up-to-%n-card">
				<test>
					<controller player="target-list.last" />
				</test>
			</target>
			<action ref="restore-library-visibility" name="%" />
			<shuffle zone="library" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : allows you to search within your library
			up to <<value>> cards (you can cancel the operation).
			| <<MACRO(value,test)>> : elle vous permet de chercher dans votre
			bibliothèque jusqu'à <<value>> cartes (vous pouvez annuler
			l'opération). -->
		<action reference-name="search-lib-up-to">
			<target-list operation="clear" name="%" />
			<target type="you" />
			<action ref="search-lib-up-to-player" />
			<target-list operation="remove-first" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : allows you to search within your library
			for one card (you cannot cancel the operation).
			| <<MACRO(test)>> : elle vous permet de chercher une carte
			dans votre bibliothèque (vous ne pouvez pas annuler l'opération). -->
		<action reference-name="search-lib">
			<target-list operation="clear" name="%" />
			<target type="you" name="%" />
			<action ref="search-lib-player" value="1" />
			<target-list operation="remove-first" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : allows the player in the first position
			of the target list to search within his library up to <<value>>
			cards (he cannot cancel the operation).
			| <<MACRO(value,test)>> : elle permet au joueur en première position
			dans la liste des cibles de chercher dans sa bibliothèque
			jusqu'à <<value>> cartes (il ne peut pas annuler l'opération). -->
		<action reference-name="search-lib-player">
			<show-zone zone="library" for="you" name="%" />
			<repeat /><!-- value ? -->
			<target mode="choose" type="card" raise-event="false" restriction-zone="library" hop="1"
				cancel="false" name="search-%n-card">
				<test>
					<controller player="target-list.first" />
				</test>
			</target>
			<action ref="restore-library-visibility" name="%" />
			<shuffle zone="library" />
		</action>

		<!--[[apt lang=en @reference-name]]
			<<MACRO(value,test)>> : allows you to search within your library 
			up to <<value>> cards and reveal them (you cannot cancel the operation).
		-->
		<action reference-name="search-lib-reveal">
			<target type="you"/>
			<action ref="search-lib-player"/>
			<target-list operation="remove-first" name="%" />
			<action ref="move-library-top"/>
			<action ref="reveal" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Reveals the cards in the target list to everyone and wait until
			the opponent decide to stop looking at your revealed cards.
			| Révèle les cartes de la liste des cibles à tout le monde et
			attend jusqu'à ce que l'adversaire décide de ne plus regarder les
			cartes révélées de cette manière. -->
		<action reference-name="reveal">
			<face-up for="everyone" name="reveal" />
			<msg type="ok" controller="opponent" name="%">
				<text>%ok_when_finished</text>
			</msg>
			<face-down for="everyone" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Allows you to look at the cards in the target list and wait
			until you decide to stop looking at these cards.
			| Elle vous permet de regarder les cartes dans la liste des cibles
			et attend jusqu'à ce que vous décidiez de ne plus regarder ces
			cartes. -->
		<action reference-name="look">
			<face-up for="you" />
			<msg type="ok" controller="you">
				<text>%ok_when_finished</text>
			</msg>
			<face-down for="you" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Allows you to look at the top card of your library. 
			The 'face-down' action should be call juste after.
			| Elle vous permet de regarder la carte du dessus de votre
			bibliothèque. L'action face-down' devrait être appelé par la suite. -->
		<action reference-name="look-at-the-top">
			<target type="card" mode="all" restriction-zone="library">
				<test>
					<and>
						<controller player="you" />
						<position position="top" />
					</and>
				</test>
			</target>
			<face-up for="you" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Moves the card referencing this action to its owner's graveyard.
			| Déplace la carte qui référence cette action dans le cimetière de
			son propriétaire. -->
		<action reference-name="finish-spell">
			<!-- TODO instead use target-index feature when implemented -->
			<target-list operation="clear" name="%" />
			<target type="this" name="%" />
			<move-card destination="graveyard" controller="target.owner" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Moves the cards in the target list to their owner libraries and
			shuffle the library of owner of the last card.
			| Déplace les cartes de la liste des cibles dans les librairies de
			leurs propriétaires respectifs et mélange la bibliothèque du propriétaire
			de la dernière carte. -->
		<action reference-name="shuffle-in-lib">
			<move-card controller="target.owner" destination="library" />
			<target type="target-list.last.owner" />
			<shuffle zone="library" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Moves the cards in the target list to their owner libraries and
			shuffle all libraries.
			| Déplace les cartes de la liste des cibles dans les librairies de
			leurs propriétaires respectifs et mélange toutes les bibliothèques. -->
		<action reference-name="shuffle-in-libs">
			<move-card controller="target.owner" destination="library" />
			<target type="player" mode="all" />
			<shuffle zone="library" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prepares the game to let you play another turn after this one.
			| Prépare le jeu de manière à ce que vous puissiez jouer un tour
			supplémentaire après celui-ci. -->
		<action reference-name="prepare-extra-turn">
			<!-- Is this extra turn is added before the normal
				turn of controller? -->
			<if-then-hop elsehop="2">
				<test>
					<controller player="currentplayer" />
				</test>
			</if-then-hop>
			<!-- Yes, so after this extra turn, the next current
				player would be the same than the one getting this
				extra turn. Else, this is the normal turn
				chaining. -->
			<modify-register register="game.static" index="normal-next-player" operation="set"
				value="2" />
			<next-current-player player="controller" />
			<unregister-this />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<Tap> the card referencing this action.
			| <Engage> la carte qui référence cette action. -->
		<action reference-name="T">
			<target type="this" name="%" />
			<tap name="@T" />
			<target-list operation="clear" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Removes the cards in the target list from combat.
			| Retire les cartes de la liste des cibles du combat. -->
		<action reference-name="remove-from-combat">
			<!-- is no more attacking, blocking, blocked, unblocked -->
			<modify-register register="this" index="state" operation="and" value="15" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Adds to the card referencing this action a replacement ability
			that triggers when this card is dealt lethal damage and replaces
			this action by removing this card from combat (if apply) and
			removing all damages that apply to it. This ability lasts until
			the end of the turn.
			| Ajoute à la carte qui référence cette action une capacité de
			remplacement qui se déclenche lorsque cette carte subit des
			dommages mortels et remplace cette action en retirant cette
			carte du combat (le cas échéant) et en retirant tout dommage
			s'appliquant à cette carte. Cette capacité dure jusqu'à la fin
			du tour. -->
		<action reference-name="regenerate">
			<create-ability>
				<save target="this" />
				<ability ref="regenerate" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Apply the <regenerate> action to the last card in the target list.
			| Applique l'action <regenerate> à la dernière carte de la liste des
			cibles. -->
		<action reference-name="regenerate-target" name="regenerate">
			<create-ability>
				<save target="target-list.last" />
				<ability ref="regenerate" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Apply the <regenerate> action to the card attached to the card
			referencing this action.
			| Applique l'action <regenerate> à la carte rattachée à la carte
			qui référence cette action. -->
		<action reference-name="regenerate-attached-to" name="regenerate">
			<create-ability>
				<save target="attachedto" />
				<ability ref="regenerate" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Removes all damages that apply to the cards in the target list.
			| Retire tous les dommages qui s'appliquent aux cartes de la liste
			des cibles. -->
		<action reference-name="remove-all-damage">
			<modify-register register="saved" index="damage" operation="clear" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Restores the visibility for you of the libraries of the players
			in the target list (<<TODO>>).
			| Restaure la visibilité pour vous concernant les bibliothèques des
			joueurs de la liste des cibles (<<TODO>>). -->
		<action reference-name="restore-library-visibility" name="%">
			<hide-zone zone="library" for="you" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Restores the visibility of the hands of the players in the target
			list for the opponent (checks whether the opponent has a special
			ability to permanently have the right to see your hand).
			| Restaure la visibilité des mains des joueurs de la liste des
			cibles pour l'adversaire (vérifie si l'adversaire a une capacité
			spéciale lui permettant de regarder votre main de manière
			permanente). -->
		<action reference-name="restore-hand-visibility" name="%" macro="false">
			<if-then-hop elsehop="2" name="%">
				<test>
					<equal right="0">
						<left register="target-list.first" index="hand-vibility-modifiers" />
					</equal>
				</test>
			</if-then-hop>
			<hide-zone zone="hand" for="opponent" name="%" />
		</action>

		<!-- Add -1/-1 to targets until end of turn
			300.4. When a phase or step ends, any effects scheduled to last
			"until end of" that phase or step expire. When a phase or step begins,
			any effects scheduled to last "until" that phase or step expire. Effects
			that last "until end of combat" expire at the end of the combat phase,
			not at the beginning of the end of combat step. Effects that last
			"until end of turn" are subject to special rules; see rule 314.2.
			
			314.2. After discarding, the following actions happen simultaneously:
			all damage is removed from permanents and all "until end of turn" and
			"this turn" effects end (this game action doesn't use the stack).
		-->
		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get -1/-1 until the end of the turn.
			| Les cartes de la liste des cibles gagnent -1/-1 jusqu'à la fin
			du tour. -->
		<action reference-name="add-1-1-until-eot">
			<add-modifier>
				<register-modifier index="power" value="1" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="1" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get -2/-2 until the end of the turn.
			| Les cartes de la liste des cibles gagnent -2/-2 jusqu'à la fin
			du tour. -->
		<action reference-name="add-2-2-until-eot">
			<add-modifier>
				<register-modifier index="power" value="2" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="2" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get -3/-3 until the end of the turn.
			| Les cartes de la liste des cibles gagnent -3/-3 jusqu'à la fin
			du tour. -->
		<action reference-name="add-3-3-until-eot">
			<add-modifier>
				<register-modifier index="power" value="3" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="3" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get -4/-4 until the end of the turn.
			| Les cartes de la liste des cibles gagnent -4/-4 jusqu'à la fin
			du tour. -->
		<action reference-name="add-4-4-until-eot">
			<add-modifier>
				<register-modifier index="power" value="4" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="4" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +1/+1 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +1/+1 jusqu'à la fin
			du tour. -->
		<action reference-name="add+1+1-until-eot">
			<add-modifier>
				<register-modifier index="power" value="1" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="1" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +7/+7 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +7/+7 jusqu'à la fin
			du tour. -->
		<action reference-name="add+7+7-until-eot">
			<add-modifier>
				<register-modifier index="power" value="7" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="7" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +6/+6 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +6/+6 jusqu'à la fin
			du tour. -->
		<action reference-name="add+6+6-until-eot">
			<add-modifier>
				<register-modifier index="power" value="6" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="6" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +1/-1 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +1/-1 jusqu'à la fin
			du tour. -->
		<action reference-name="add+1-1-until-eot">
			<add-modifier>
				<register-modifier index="power" value="1" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="1" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +2/-2 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +2/-2 jusqu'à la fin
			du tour. -->
		<action reference-name="add+2-2-until-eot">
			<add-modifier>
				<register-modifier index="power" value="2" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="2" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>
		
		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +3/-3 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +3/-3 jusqu'à la fin
			du tour. -->
		<action reference-name="add+3-3-until-eot">
			<add-modifier>
				<register-modifier index="power" value="3" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="3" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>
		
		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get -2/+2 until the end of the turn.
			| Les cartes de la liste des cibles gagnent -2/+2 jusqu'à la fin
			du tour. -->
		<action reference-name="add-2+2-until-eot">
			<add-modifier>
				<register-modifier index="power" value="2" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="2" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +1/-1 until the end of the turn.
			| Les cartes de la liste des cibles gagnent -1/+1 jusqu'à la fin
			du tour. -->
		<action reference-name="add-1+1-until-eot">
			<add-modifier>
				<register-modifier index="power" value="1" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="1" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +2/-1 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +2/-1 jusqu'à la fin
			du tour. -->
		<action reference-name="add+2-1-until-eot">
			<add-modifier>
				<register-modifier index="power" value="2" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="1" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get -1/-0 until the end of the turn.
			| Les cartes de la liste des cibles gagnent -1/-0 jusqu'à la fin
			du tour. -->
		<action reference-name="add-1-0-until-eot">
			<add-modifier>
				<register-modifier index="power" value="1" operation="minus" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +1/+2 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +1/+2 jusqu'à la fin
			du tour. -->
		<action reference-name="add+1+2-until-eot">
			<add-modifier>
				<register-modifier index="power" value="1" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="2" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +2/+2 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +2/+2 jusqu'à la fin
			du tour. -->
		<action reference-name="add+2+2-until-eot">
			<add-modifier>
				<register-modifier index="power" value="2" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="2" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +3/+3 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +3/+3 jusqu'à la fin
			du tour. -->
		<action reference-name="add+3+3-until-eot">
			<add-modifier>
				<register-modifier index="power" value="3" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="3" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +4/+4 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +4/+4 jusqu'à la fin
			du tour. -->
		<action reference-name="add+4+4-until-eot">
			<add-modifier>
				<register-modifier index="power" value="4" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="4" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +5/+5 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +5/+5 jusqu'à la fin
			du tour. -->
		<action reference-name="add+5+5-until-eot">
			<add-modifier>
				<register-modifier index="power" value="5" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="5" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +2/+1 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +2/+1 jusqu'à la fin
			du tour. -->
		<action reference-name="add+2+1-until-eot">
			<add-modifier>
				<register-modifier index="power" value="2" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
				<register-modifier index="toughness" value="1" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +3/+0 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +3/+0 jusqu'à la fin
			du tour. -->
		<action reference-name="add+3+0-until-eot">
			<add-modifier>
				<register-modifier index="power" value="3" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +4/+0 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +4/+0 jusqu'à la fin
			du tour. -->
		<action reference-name="add+4+0-until-eot">
			<add-modifier>
				<register-modifier index="power" value="4" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +2/+0 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +2/+0 jusqu'à la fin
			du tour. -->
		<action reference-name="add+2+0-until-eot">
			<add-modifier>
				<register-modifier index="power" value="2" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +2/+0 until the end of the combat.
			| Les cartes de la liste des cibles gagnent +2/+0 jusqu'à la fin
			du combat. -->
		<action reference-name="add+2+0-until-eoc">
			<add-modifier>
				<register-modifier index="power" value="2" operation="add" linked="false">
					<until>
						<end-of-phase phase="eoc" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +1/+0 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +1/+0 jusqu'à la fin
			du tour. -->
		<action reference-name="add+1+0-until-eot">
			<add-modifier>
				<register-modifier index="power" value="1" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +0/+1 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +0/+1 jusqu'à la fin
			du tour. -->
		<action reference-name="add+0+1-until-eot">
			<add-modifier>
				<register-modifier index="toughness" value="1" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +0/+2 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +0/+2 jusqu'à la fin
			du tour. -->
		<action reference-name="add+0+2-until-eot">
			<add-modifier>
				<register-modifier index="toughness" value="2" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +0/+3 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +0/+3 jusqu'à la fin
			du tour. -->
		<action reference-name="add+0+3-until-eot">
			<add-modifier>
				<register-modifier index="toughness" value="3" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get +0/+5 until the end of the turn.
			| Les cartes de la liste des cibles gagnent +0/+5 jusqu'à la fin
			du tour. -->
		<action reference-name="add+0+5-until-eot">
			<add-modifier>
				<register-modifier index="toughness" value="5" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list get -2/+0 until the end of the turn.
			Example : {{{mtg/cards/Ivory\_Charm.html}Ivory Charm}}
			| Les cartes de la liste des cibles gagnent -2/-0 jusqu'à la fin
			du tour. 
			Exemple : {{{mtg/cards/Ivory\_Charm.html}Ivory Charm}}
		-->
		<action reference-name="add-2-0-until-eot">
			<add-modifier>
				<register-modifier index="power" value="2" operation="add" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</register-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			The card referencing this action gets -1/-1 until the end of the turn.
			| La carte qui référence cette action gagne -1/-1 jusqu'à la fin
			du tour. -->
		<action reference-name="gain-1-1-until-eot">
			<target type="this" name="%" />
			<action ref="add-1-1-until-eot" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			The card referencing this action gets +1/+1 until the end of the turn.
			| La carte qui référence cette action gagne +1/+1 jusqu'à la fin
			du tour. -->
		<action reference-name="gain+1+1-until-eot">
			<target type="this" name="%" />
			<action ref="add+1+1-until-eot" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			The card referencing this action gets +1/+0 until the end of the turn.
			| La carte qui référence cette action gagne +1/+0 jusqu'à la fin
			du tour. -->
		<action reference-name="gain+1+0-until-eot">
			<target type="this" name="%" />
			<action ref="add+1+0-until-eot" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			The card referencing this action gets +2/+0 until the end of the turn.
			| La carte qui référence cette action gagne +2/+0 jusqu'à la fin
			du tour. -->
		<action reference-name="gain+2+0-until-eot">
			<target type="this" name="%" />
			<action ref="add+2+0-until-eot" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			The card referencing this action gets +0/+1 until the end of the turn.
			| La carte qui référence cette action gagne +0/+1 jusqu'à la fin
			du tour. -->
		<action reference-name="gain+0+1-until-eot">
			<target type="this" name="%" />
			<action ref="add+0+1-until-eot" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			The card referencing this action gets +0/+2 until the end of the turn.
			| La carte qui référence cette action gagne +0/+2 jusqu'à la fin
			du tour. -->
		<action reference-name="gain+0+2-until-eot">
			<target type="this" name="%" />
			<action ref="add+0+2-until-eot" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			The card referencing this action gets +2/+2 until the end of the turn.
			| La carte qui référence cette action gagne +2/+2 jusqu'à la fin
			du tour. -->
		<action reference-name="gain+2+2-until-eot">
			<target type="this" name="%" />
			<action ref="add+2+2-until-eot" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			The card referencing this action gets +3/+3 until the end of the turn.
			| La carte qui référence cette action gagne +3/+3 jusqu'à la fin
			du tour. -->
		<action reference-name="gain+3+3-until-eot">
			<target type="this" name="%" />
			<action ref="add+3+3-until-eot" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			The card referencing this action gets +1/+2 until the end of the turn.
			| La carte qui référence cette action gagne +1/+2 jusqu'à la fin
			du tour. -->
		<action reference-name="gain+1+2-until-eot">
			<target type="this" name="%" />
			<action ref="add+1+2-until-eot" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			The card referencing this action gets +1/-1 until the end of the turn.
			| La carte qui référence cette action gagne +1/-1 jusqu'à la fin
			du tour. -->
		<action reference-name="gain+1-1-until-eot">
			<target type="this" name="%" />
			<action ref="add+1-1-until-eot" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list become <unblockable> until the end of
			the turn.
			| Les cartes de la liste des cibles deviennent <imblocables>
			jusqu'à la fin du tour. -->
		<action reference-name="unblockable-until-eot">
			<add-modifier>
				<property-modifier property="unblockable" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list gain <flying> until the end of the turn.
			Example : {{{mtg/cards/Raka\_Disciple.html}Raka Disciple}}
			| Les cartes de la liste des cibles gagnent le <vol> jusqu'à la
			fin du tour. 
			Exemple : {{{mtg/cards/Raka\_Disciple.html}Raka Disciple}}
		-->
		<action reference-name="flying-until-eot">
			<add-modifier>
				<property-modifier property="flying" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>
		
		<!--[[apt lang=en @reference-name]]
			Cards in the target list gain <flying> until the end of the turn.
			Example : {{{mtg/cards/Blades\_of\_Velis_Vel.html}Blades of Velis Vel}}
		-->
		<action reference-name="changeling-until-eot">
			<add-modifier>
				<property-modifier property="changeling" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list gain <fear> until the end of the turn
			(they are <unblockable> except by black or artifact creatures).
			| Les cartes de la liste des cibles gagnent la <peur> jusqu'à la
			fin du tour (elle sont <imblocables> sauf par des créatures
			noires ou artefacts). -->
		<action reference-name="fear-until-eot">
			<add-modifier>
				<property-modifier property="fear" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list gain <shadow> until the end of the turn
			(they can <bloc> or be <blocked> only by creatures with <shadow>).
			| Les cartes de la liste des cibles gagnent la <distorsion> jusqu'à la
			fin du tour (elles ne peuvent <bloquer> ou être <bloquées> que
			par des créatures avec la <distorsion>). -->
		<action reference-name="shadow-until-eot">
			<add-modifier>
				<property-modifier property="shadow" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list are allowed to attack this turn
			(if possible) even if they have <defender>.
			| Les cartes de la liste des cibles sont autorisées à attaquer ce
			tour-ci (si possible) même si elles ont la <défense>. -->
		<action reference-name="wall-can-attack-until-eot">
			<add-modifier>
				<property-modifier property="wall-can-attack" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list gain <haste> until the end of the turn
			(they can attack the turn they came into play).
			| Les cartes de la liste des cibles gagnent la <célérité> jusqu'à
			la fin du tour (elle peuvent attaquer durant le tour où elles
			sont arrivées en jeu). -->
		<action reference-name="haste-until-eot">
			<add-modifier>
				<property-modifier property="haste" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list gain <trample> until the end of the turn.
			| Les cartes de la liste des cibles gagnent le <piétinement> jusqu'à
			la fin du tour. -->
		<action reference-name="trample-until-eot">
			<add-modifier>
				<property-modifier property="trample" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list gain <banding> until the end of the turn.
			| Les cartes de la liste des cibles gagnent le <regroupement> jusqu'à
			la fin du tour. -->
		<action reference-name="banding-until-eot">
			<add-modifier>
				<property-modifier property="banding" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list gain <first strike> until the end of the turn.
			| Les cartes de la liste des cibles gagnent l'<initiative> jusqu'à
			la fin du tour. -->
		<action reference-name="first-strike-until-eot">
			<add-modifier>
				<property-modifier property="first-strike" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list gain <double strike> until the end of the turn.
			| Les cartes de la liste des cibles gagnent <double strike> jusqu'à
			la fin du tour. -->
		<action reference-name="double-strike-until-eot">
			<add-modifier>
				<property-modifier property="double-strike" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list gain <vigilance> until the end of the turn
			(attacking does not cause them to <tap>).
			| Les cartes de la liste des cibles gagnent la <vigilance> jusqu'à
			la fin du tour (attaquer ne les fait pas s'<engager>). -->
		<action reference-name="vigilance-until-eot">
			<add-modifier>
				<property-modifier property="vigilance" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Cards in the target list can't be the target of spells of
			abilities until the end of the turn.
			| Les cartes de la liste des cibles ne peuvent pas être la cible
			de sorts ou de capacités jusqu'à la fin du tour. -->
		<action reference-name="shroud-until-eot">
			<add-modifier>
				<property-modifier property="shroud" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en @reference-name]]
			Cards in the target list can block as if they had flying 
			until the end of the turn.
		-->
		<action reference-name="reach-until-eot">
			<add-modifier>
				<property-modifier property="reach" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en @reference-name]]
			Cards in the target list attack if able 
			until the end of the turn.
		-->
		<action reference-name="attacks-if-able-until-eot">
			<add-modifier>
				<property-modifier property="attacks-if-able" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en @reference-name]]
			Cards in the target list cannot block
			until the end of the turn.
		-->
		<action reference-name="cannot-block-until-eot">
			<add-modifier>
				<property-modifier property="cannot-block" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en @reference-name]]
			Cards in the target list cannot attack
			until the end of the turn.
		-->
		<action reference-name="cannot-attack-until-eot">
			<add-modifier>
				<property-modifier property="cannot-attack" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en @reference-name]]
			Cards in the target list gain forestwalk
			until the end of the turn.
		-->
		<action reference-name="forestwalk-until-eot">
			<add-modifier>
				<property-modifier property="forestwalk" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en @reference-name]]
			Cards in the target list gain islandwalk
			until the end of the turn.
		-->
		<action reference-name="islandwalk-until-eot">
			<add-modifier>
				<property-modifier property="islandwalk" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en @reference-name]]
			Cards in the target list gain protection from red
			until the end of the turn.
		-->
		<action reference-name="protection-from-red-until-eot">
			<add-modifier>
				<property-modifier property="protection-from-red" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>
		
		<!--[[apt lang=en @reference-name]]
			Cards in the target list gain protection from black
			until the end of the turn.
		-->
		<action reference-name="protection-from-black-until-eot">
			<add-modifier>
				<property-modifier property="protection-from-black" linked="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
				</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en @reference-name]]
			Cards in the target list don't untap during their controller's next
			untap step.
		-->
		<action reference-name="does-not-untap-next-untap">
			<add-modifier>
				<property-modifier property="does-not-untap" linked="false">
			 		<until>
			 			<end-of-phase phase="untap"/>
			 		</until>
			 	</property-modifier>
			</add-modifier>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Returns the cards in the target list to their owner's hand.
			| Retourne les cartes de la liste des cibles dans la main de leurs
			propriétaires. -->
		<action reference-name="return-to-hand">
			<move-card destination="hand" controller="target.owner" name="" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Moves the cards in the target list to the top of their owner's
			library.
			| Déplace les cartes de la liste des cibles au dessus de la
			bibliothèque de leurs propriétaires. -->
		<action reference-name="move-library-top">
			<move-card destination="library" controller="owner" position="top" name="" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Moves the cards in the target list to the bottom of their owner's
			library. -->
		<action reference-name="move-library-bottom">
			<move-card destination="library" controller="owner" position="bottom" name="" />
		</action> 

		<!--[[apt lang=en|fr @reference-name]]
			Removes the cards in the target list from the game (they are
			moved to the <side> zone, <<\[TODO\]>> creating a dedicated zone
			for such cards should be considered).
			| Retire les cartes de la liste des cibles du jeu (elles sont
			déplacées vers la zone <side>, <<\[TODO\]>> créer une zone
			dédiée pour de telles cartes devrait être considéré). -->
		<action reference-name="remove-from-game">
			<move-card destination="side" controller="target.owner" name="" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Puts the cards in the target list in their owner's graveyard.
			| Déplace les cartes de la liste des cibles dans le cimetière de
			leurs propriétaires. -->
		<action reference-name="put-in-graveyard">
			<move-card destination="graveyard" controller="target.owner" name="" />
		</action>

		<!--[[apt lang=en @reference-name]]
			Puts the top card of target player's library to his graveyard.
			| Déplace la carte du dessus de la bibliothèque du dernier joueur ciblé 
			dans son cimetière. -->
		<action reference-name="mill-a-card">
			<target type="card" mode="all" restriction-zone="library">
				<test>
					<and>
						<position position="top" />
						<controller player="target-list.last" />
					</and>
				</test>
			</target>
			<action ref="put-in-graveyard" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Makes the players in the target list draw a card.
			Example : {{{mtg/cards/Bandage.html}Bandage}}
			| Fait piocher une carte aux joueurs de la liste des cibles. 
			Exemple : {{{mtg/cards/Bandage.html}Bandage}}
		-->
		<action reference-name="draw-a-card">
			<move-player-card from="library" to="hand" controller="owner" name="draw-%n-card" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Makes the players in the target list removes the top card of
			their library from the game. The target list is cleared after
			this operation.
			| Retire du jeu la carte du dessus de la bibliothèque des joueurs
			de la liste des cibles. Cette liste est vidée après cette
			opération. -->
		<action reference-name="remove-a-card-from-library">
			<move-player-card from="library" to="side" controller="owner" name="" />
			<target-list operation="clear" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Allows the players in the target list to choose a card from
			their graveyard to be removed from the game. The target list is
			cleared after this operation.
			| Elle permet aux joueurs de la liste des cibles de choisir une
			carte de leur cimetière afin qu'elle soit retirée du jeu. La
			liste des cibles est vidée après cette opération. -->
		<action reference-name="remove-a-card-from-graveyard">
			<target type="card" restriction-zone="graveyard" mode="choose" raise-event="false" />
			<action ref="remove-from-game" />
			<target-list operation="clear" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Makes you draw a card during the next turn upkeep.
			Example : {{{mtg/cards/Heal.html}Heal}}
			| Elle vous fait piocher une carte durant l'entretien du prochain
			tour. 
			Exemple : {{{mtg/cards/Heal.html}Heal}}
		-->
		<action reference-name="draw-a-card-next-upkeep" name="draw-%n-card-next-upkeep">
			<create-ability>
				<save target="you" />
				<triggered-ability zone="play">
					<beginning-of-phase phase="upkeep">
						<test ref="during-your-upkeep" />
					</beginning-of-phase>
					<effects>
						<target type="saved" />
						<action ref="draw-a-card" />
					</effects>
				</triggered-ability>
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Makes the opponent draw a card during the next turn upkeep.
			| Elle fait piocher une carte à l'adversaire durant l'entretien du
			prochain tour. -->
		<action reference-name="opponent-draw-a-card-next-upkeep" name="draw-%n-card-next-upkeep">
			<create-ability>
				<save target="opponent" />
				<triggered-ability zone="play">
					<beginning-of-phase phase="upkeep">
						<test ref="during-your-upkeep" />
					</beginning-of-phase>
					<effects>
						<target type="saved" />
						<action ref="draw-a-card" />
					</effects>
				</triggered-ability>
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!-- MACRO (value) : Pay X lives
			WARNING, according to Magic rules, player must have the required lives to
			play this action. So a test life the following must be place in ability :
			<test>
			<or>
			<equals right="0" left="%value"/>
			<sup right="0">
			<minus right="%value>
			<left register="controller" index="life"/>
			</minus>
			</sup>
			</or>
			</test>
		-->
		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value)>> : makes the controller of the card referencing
			this action pay <<value>> points of life. Beware, a test must be
			used to check whether the player have enough life to play this
			action (check <<<mtg.xml>>> for more information).
			| <<MACRO(value)>> : fait payer <<value>> points de vie au
			contrôleur de la carte qui référence cette action. Attention,
			un test devra être utilisé afin de vérifier que ce joueur a
			assez de points de vie pour joueur cette action (vérifiez
			<<<mtg.xml>>> pour plus d'informations). -->
		<action reference-name="pay-life" name="pay-%n-life">
			<modify-register register="controller" index="life" operation="minus" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value)>> : makes the controller of the card referencing
			this action gain <<value>> points of life.
			| <<MACRO(value)>> : fait gagner <<value>> points de vie au
			contrôleur de la carte qui référence cette action. -->
		<action reference-name="gain-life" name="gain-%n-life">
			<modify-register register="controller" index="life" operation="add" />
		</action>

		<!--[[apt lang=en @reference-name]]
			<<MACRO(value)>> : makes the <<targets>> of the card referencing
			this action gain <<value>> points of life. -->
		<action reference-name="gain-life-target" name="gain-%n-life">
			<modify-register register="target" index="life" operation="add" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value)>> : makes the controller of the card referencing
			this action loose <<value>> points of life.
			| <<MACRO(value)>> : fait perdre <<value>> points de vie au
			contrôleur de la carte qui référence cette action. -->
		<action reference-name="lose-life" name="lose-%n-life">
			<modify-register register="controller" index="life" operation="minus" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value)>> : makes the players in the target list loose
			<<value>> points of life.
			| <<MACRO(value)>> : fait perdre <<value>> points de vie aux
			joueurs de la liste des cibles. -->
		<action reference-name="lose-life-target" name="lose-%n-life">
			<modify-register register="target" index="life" operation="minus" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : makes you choose <<value>> cards from
			your hand and discard them.
			| <<MACRO(value,test)>> : elle vous fait choisir et défausser
			<<value>> cartes depuis votre main. -->
		<action reference-name="discard">
			<repeat /><!-- value ? -->
			<target type="card" mode="choose" restriction-zone="hand" raise-event="false" hop="1"
				cancel="false" name="discard-%n-card">
				<test>
					<controller player="you" />
				</test>
			</target>
			<action ref="discard-cards_noname" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : makes you discard <<value>> cards at random  from
			your hand.
			| <<MACRO(value,test)>> : elle vous fait défausser au hazard
			<<value>> cartes depuis votre main. -->
		<action reference-name="discard-random">
			<repeat /><!-- value ? -->
			<target type="card" mode="random" restriction-zone="hand" raise-event="false"
				cancel="false" name="discard-%n-card">
				<test>
					<controller player="you" />
				</test>
			</target>
			<action ref="discard-cards_noname" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : makes the opponent choose <<value>>
			cards from his hand and discard them.
			| <<MACRO(value,test)>> : elle fait choisir et défausser
			<<value>> cartes à l'adversaire depuis sa main. -->
		<action reference-name="opponent-discards">
			<repeat />
			<!-- value ? -->
			<target type="card" mode="opponentchoose" restriction-zone="hand" raise-event="false"
				hop="1" cancel="false" name="discard-%n-card">
				<test>
					<controller player="opponent" />
				</test>
			</target>
			<action ref="discard-cards_noname" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : makes you choose <<value>> cards from
			the hand of the players in the target list and discard them.
			| <<MACRO(value,test)>> : elle vous fait choisir et défausser
			<<value>> cartes depuis la main des joueurs de la liste des
			cibles. -->
		<action reference-name="discard-a-player">
			<show-zone zone="hand" for="you" name="%" />
			<repeat />
			<!-- value ? -->
			<target type="card" mode="choose" restriction-zone="hand" raise-event="false" hop="1"
				cancel="false" name="discard-%n-card">
				<test>
					<controller player="target-list.first" />
				</test>
			</target>
			<action ref="restore-hand-visibility" name="%" />
			<action ref="discard-cards_noname" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : makes the player in the first position in
			the target list choose <<value>> cards from his hand and discard
			them.
			| <<MACRO(value,test)>> : elle fait choisir et défausser
			<<value>> cartes au joueur en première position dans la liste des
			cibles depuis sa main. -->
		<action reference-name="player-discard">
			<repeat />
			<!-- value ? -->
			<target type="card" mode="target-choose" restriction-zone="hand" raise-event="false"
				hop="1" cancel="false" name="discard-%n-card">
				<test>
					<controller player="target-list.first" />
				</test>
			</target>
			<action ref="discard-cards_noname" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : makes the player in the first position in
			the target list discard <<value>> cards from his hand at random.
		-->
		<action reference-name="player-discard-random">
			<repeat />
			<!-- value ? -->
			<target type="card" mode="random" restriction-zone="hand" raise-event="false" hop="1"
				cancel="false" name="discard-%n-card">
				<test>
					<controller player="target-list.first" />
				</test>
			</target>
			<action ref="discard-cards_noname" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : makes the player in the first position in
			the target list choose up to <<value>> cards from his hand and discard
			them.
			| <<MACRO(value,test)>> : elle fait choisir et défausser jusqu'à
			<<value>> cartes au joueur en première position dans la liste des
			cibles depuis sa main. -->
		<action reference-name="player-discard-up-to">
			<repeat />
			<!-- value ? -->
			<target type="card" mode="target-choose" restriction-zone="hand" raise-event="false"
				hop="1" cancel="true" name="discard-up-to-%n-card">
				<test>
					<controller player="target-list.first" />
				</test>
			</target>
			<action ref="discard-cards_noname" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Moves the cards in the target list to their owner's graveyard
			(this action is not named).
			| Déplace les cartes de la liste des cibles dans le cimetière de
			leur propriétaires (cette action n'est pas nommée). -->
		<action reference-name="discard-cards_noname" name="%">
			<action ref="put-in-graveyard" />
			<target-list operation="clear" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Moves the cards in the target list to their owner's graveyard.
			| Déplace les cartes de la liste des cibles dans le cimetière de
			leur propriétaires. -->
		<action reference-name="discard-cards">
			<action ref="put-in-graveyard" />
			<target-list operation="clear" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Destroys the cards in the target-list.
			| Détruire les cartes présentes dans la liste de cibles. -->
		<action reference-name="destroy">
			<assign-damage value="all" type="damage-normal" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Destroys the cards in the target-list. The destroyed card cannot be 
			regenerated.
			| Détruire les cartes présentes dans la liste de cibles. Les cartes 
			détruites ne peuvent être régénérées. -->
		<action reference-name="bury">
			<assign-damage value="all" type="damage-cannot-be-regenerated" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Destroys the first card of the target-list at the end of turn.
			| Détruit le première carte de la liste de cibles à la fin du tour. -->
		<action reference-name="destroy-target-eot">
			<create-ability>
				<save target="target-list.first" />
				<triggered-ability zone="play">
					<end-of-phase phase="eot" />
					<effects>
						<target type="saved" />
						<action ref="destroy" />
						<unregister-this />
					</effects>
				</triggered-ability>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Destroys the first card of the target-list at the end of combat. -->
		<action reference-name="destroy-target-eoc">
			<create-ability>
				<save target="target-list.first" />
				<triggered-ability zone="play">
					<end-of-phase phase="eoc" />
					<effects>
						<target type="saved" />
						<action ref="destroy" />
						<unregister-this />
					</effects>
				</triggered-ability>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Removes from game the first card of the target-list at the end of turn.
			| Retire de la partie le première carte de la liste de cibles à la fin 
			du tour. -->
		<action reference-name="remove-from-game-target-eot">
			<create-ability>
				<save target="target-list.first" />
				<triggered-ability zone="play">
					<end-of-phase phase="eot" />
					<effects>
						<target type="saved" />
						<action ref="remove-from-game" />
						<unregister-this />
					</effects>
				</triggered-ability>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Returns to play the first card of the target-list at the end of turn. -->
		<action reference-name="return-to-play-target-eot">
			<create-ability>
				<save target="target-list.first" />
				<triggered-ability zone="play">
					<end-of-phase phase="eot" />
					<effects>
						<target type="saved" />
						<action ref="move-to-play" />
						<unregister-this />
					</effects>
				</triggered-ability>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Sacrifices this card (Move the card into the graveyard of his/her owner).
			| Sacrifie cette carte (Mettre la carte dans cimetière de son propriétaire). -->
		<action reference-name="sacrifice-this">
			<target-list operation="clear" name="%" />
			<target type="this" name="%" />
			<move-card controller="target.owner" destination="graveyard" name="sacrifice-this" />
			<target-list operation="clear" name="%" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(test)>> : Sacrifices <<value>> chosen creatures. 
			| <<MACRO(test)>> : Sacrifie <<value>> créatures choisies. 
		-->
		<action reference-name="sacrifice-a-creature">
			<repeat value="all" />
			<target type="card" mode="choose" raise-event="false" restriction-zone="play" name="%"
				cancel="false" hop="1">
				<test>
					<and>
						<has-idcard idcard="creature" />
						<controller player="you" />
					</and>
				</test>
			</target>
			<action ref="sacrifice" name="sacrifice-%n-creature" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : Sacrifice sany chosen creatures. 
			| <<MACRO(value,test)>> : Sacrifie n'importe quel nombre de créatures choisies. 
		-->
		<action reference-name="sacrifice-any-creature">
			<repeat />
			<!-- value ? -->
			<target type="card" mode="choose" raise-event="false" restriction-zone="play" name="%"
				cancel="false" hop="1">
				<test>
					<and>
						<has-idcard idcard="creature" />
						<controller player="you" />
					</and>
				</test>
			</target>
			<action ref="sacrifice" name="sacrifice-any-creature" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : Sacrifices <<value>> chosen permanents. 
			| <<MACRO(value,test)>> : Sacrifie <<value>> permanants choisis. 
		-->
		<action reference-name="sacrifice-a-permanent">
			<repeat />
			<!-- value ? -->
			<target type="card" mode="choose" raise-event="false" restriction-zone="play" name="%"
				cancel="false" hop="1">
				<test>
					<controller player="you" />
				</test>
			</target>
			<action ref="sacrifice" name="sacrifice-%n-permanent" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : Makes the opponent sacrifice <<value>> chosen permanents. 
			| <<MACRO(value,test)>> : Sacrifie <<value>> permanants choisis. 
		-->
		<action reference-name="opponent-sacrifice-a-permanent">
			<repeat />
			<!-- value ? -->
			<target type="card" mode="choose" raise-event="false" restriction-zone="play" name="%"
				cancel="false" hop="1">
				<test>
					<controller player="opponent" />
				</test>
			</target>
			<action ref="sacrifice" name="sacrifice-%n-permanent" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : Makes the opponent sacrifices <<value>> chosen creatures. 
			| <<MACRO(value,test)>> : L'adversaire sacrifie <<value>> créatures choisies. 
		-->
		<action reference-name="opponent-sacrifice-a-creature">
			<repeat />
			<!-- value ? -->
			<target type="card" mode="opponentchoose" raise-event="false" restriction-zone="play"
				name="%" cancel="false" hop="1">
				<test>
					<and>
						<has-idcard idcard="creature" />
						<controller player="opponent" />
					</and>
				</test>
			</target>
			<action ref="sacrifice" name="sacrifice-%n-creature" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : Sacrifices <<value>> chosen artifacts. 
			| <<MACRO(value,test)>> : Sacrifie <<value>> artefacts choisis. 
		-->
		<action reference-name="sacrifice-an-artifact">
			<repeat /><!-- value ? -->
			<target type="card" mode="choose" raise-event="false" restriction-zone="play" name="%"
				cancel="false" hop="1">
				<test>
					<and>
						<has-idcard idcard="artifact" />
						<controller player="you" />
					</and>
				</test>
			</target>
			<action ref="sacrifice" name="sacrifice-%n-artifact" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : Sacrifices <<value>> chosen enchantments. 
			| <<MACRO(value,test)>> : Sacrifie <<value>> enchantements choisis. 
		-->
		<action reference-name="sacrifice-an-enchantment">
			<repeat /><!-- value ? -->
			<target type="card" mode="choose" raise-event="false" restriction-zone="play" name="%"
				cancel="false" hop="1">
				<test>
					<and>
						<has-idcard idcard="enchantment" />
						<controller player="you" />
					</and>
				</test>
			</target>
			<action ref="sacrifice" name="sacrifice-%n-enchantment" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : Makes the opponent sacrifice <<value>> chosen enchantments. 
			| <<MACRO(value,test)>> : L'adversaire sacrifie <<value>> enchantements choisis. 
		-->
		<action reference-name="opponent-sacrifice-an-enchantment">
			<repeat /><!-- value ? -->
			<target type="card" mode="opponentchoose" raise-event="false" restriction-zone="play"
				name="%" cancel="false" hop="1">
				<test>
					<and>
						<has-idcard idcard="enchantment" />
						<controller player="opponent" />
					</and>
				</test>
			</target>
			<action ref="sacrifice" name="sacrifice-%n-enchantment" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : Makes the opponent sacrifice <<value>> chosen artifacts. 
			| <<MACRO(value,test)>> : L'adversaire sacrifie <<value>> artifacts choisis. 
		-->
		<action reference-name="opponent-sacrifice-an-artifact">
			<repeat />
			<!-- value ? -->
			<target type="card" mode="opponentchoose" raise-event="false" restriction-zone="play"
				name="%" cancel="false" hop="1">
				<test>
					<and>
						<has-idcard idcard="artifact" />
						<controller player="opponent" />
					</and>
				</test>
			</target>
			<action ref="sacrifice" name="sacrifice-%n-artifact" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : Sacrifices <<value>> chosen lands. 
			| <<MACRO(value,test)>> : Sacrifie <<value>> terrains choisis. 
		-->
		<action reference-name="sacrifice-a-land">
			<repeat />
			<!-- value ? -->
			<target type="card" mode="choose" raise-event="false" restriction-zone="play" name="%"
				cancel="false" hop="1">
				<test>
					<and>
						<has-idcard idcard="land" />
						<controller player="you" />
					</and>
				</test>
			</target>
			<action ref="sacrifice" name="sacrifice-%n-land" />
		</action>
		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(value,test)>> : Makes the opponent sacrifices <<value>> chosen lands. 
			| <<MACRO(value,test)>> : L'adversaire sacrifie <<value>> terrains choisis. 
		-->
		<action reference-name="opponent-sacrifice-a-land">
			<repeat />
			<!-- value ? -->
			<target type="card" mode="opponentchoose" raise-event="false" restriction-zone="play"
				name="%" cancel="false" hop="1">
				<test>
					<and>
						<has-idcard idcard="land" />
						<controller player="opponent" />
					</and>
				</test>
			</target>
			<action ref="sacrifice" name="sacrifice-%n-land" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Sacrifices the cards of the target-list. 
			| Sacrifie les cartes présentes dans la liste de cibles. 
		-->
		<action reference-name="sacrifice">
			<move-card controller="target.owner" destination="graveyard" name="sacrifice-target" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Redirects the all damage from first target to this card
			until end of turn. 
			| Redirige l'ensemble des dégats de la première cible vers cette carte 
			jusqu'à la fin du tour.
		-->
		<action reference-name="redirect-all-to-this">
			<create-ability>
				<save target="target-list.first" target2="this" />
				<ability ref="redirect-all" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Redirects the next 1 damage from this to the first target
			until end of turn. 
			Example : {{{mtg/cards/Nomads\_en\_Kor.html}Nomads en-Kor}}
			| Redirige le prochain dommage issu de cette carte vers la première cible 
			jusqu'à la fin du tour.
			Exemple : {{{mtg/cards/Nomads\_en\_Kor.html}Nomads en-Kor}}
		-->
		<action reference-name="redirect-1-from-this">
			<create-ability>
				<registers>
					<register index="0" value="1" />
				</registers>
				<save target="this" target2="target-list.first" />
				<ability ref="redirect-X" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Redirects the next 2 damage from this to the first target
			until end of turn. 
			| Redirige les 2 prochains dommages issus de cette carte vers la première cible 
			jusqu'à la fin du tour.
		-->
		<action reference-name="redirect-2-from-this">
			<create-ability>
				<registers>
					<register index="0" value="2" />
				</registers>
				<save target="this" target2="target-list.first" />
				<ability ref="redirect-X" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Redirects the next 3 damage from this to the first target
			until end of turn. 
			| Redirige les 3 prochains dommages issus de cette carte vers la première cible 
			jusqu'à la fin du tour.
		-->
		<action reference-name="redirect-3-from-this">
			<create-ability>
				<registers>
					<register index="0" value="3" />
				</registers>
				<save target="this" target2="target-list.first" />
				<ability ref="redirect-X" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Redirects all damage from this to the first target
			until end of turn. 
			| Redirige tous les prochains dommages issus de cette carte vers la première cible 
			jusqu'à la fin du tour.
		-->
		<action reference-name="redirect-all-from-this">
			<create-ability>
				<save target="this" target2="target-list.first" />
				<ability ref="redirect-all" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Redirects the all damage from first target to the second target
			until end of turn. 
			| Redirige l'ensemble des dommages de la première cible vers la seconde 
			jusqu'à la fin du tour.
		-->
		<action reference-name="redirect-all">
			<create-ability>
				<save target="target-list.first" target2="target-list.last" />
				<ability ref="redirect-all" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Redirects the next 1 damage from first target to the second target
			until end of turn. 
			| Redirige le prochain dommage de la première cible vers la seconde 
			jusqu'à la fin du tour.
		-->
		<action reference-name="redirect-1">
			<create-ability>
				<registers>
					<register index="0" value="1" />
				</registers>
				<save target="target-list.first" target2="target-list.last" />
				<ability ref="redirect-X" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Redirects the next 2 damage from first target to the second target
			until end of turn. 
			| Redirige les 2 prochains dommages de la première cible vers la seconde 
			jusqu'à la fin du tour.
		-->
		<action reference-name="redirect-2">
			<create-ability>
				<registers>
					<register index="0" value="2" />
				</registers>
				<save target="target-list.first" target2="target-list.last" />
				<ability ref="redirect-X" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Redirects the next 3 damage from first target to the second target
			until end of turn. 
			| Redirige les 3 prochains dommages de la première cible vers la seconde 
			jusqu'à la fin du tour.
		-->
		<action reference-name="redirect-3">
			<create-ability>
				<registers>
					<register index="0" value="3" />
				</registers>
				<save target="target-list.first" target2="target-list.last" />
				<ability ref="redirect-X" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Redirects the next 1 damage from first target to this card
			until end of turn. 
			Example : {{{mtg/cards/Daughter\_of\_Autumn.html}Daughter of Autumn}}
			| Redirige le prochain dommage de la première cible vers cette carte 
			jusqu'à la fin du tour.
			Exemple : {{{mtg/cards/Daughter\_of\_Autumnl.html}Daughter of Autumn}}
		-->
		<action reference-name="redirect-1-to-this">
			<create-ability>
				<registers>
					<register index="0" value="1" />
				</registers>
				<save target="target-list.first" target2="this" />
				<ability ref="redirect-X" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Redirects the next 2 damage from first target to this card
			until end of turn. 
			| Redirige les 2 prochains dommages de la première cible vers cette carte 
			jusqu'à la fin du tour.
		-->
		<action reference-name="redirect-2-to-this">
			<create-ability>
				<registers>
					<register index="0" value="2" />
				</registers>
				<save target="target-list.first" target2="this" />
				<ability ref="redirect-X" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Redirects the next 3 damage from first target to this card
			until end of turn. 
			| Redirige les 3 prochains dommages de la première cible vers cette carte 
			jusqu'à la fin du tour.
		-->
		<action reference-name="redirect-3-to-this">
			<create-ability>
				<registers>
					<register index="0" value="3" />
				</registers>
				<save target="target-list.first" target2="this" />
				<ability ref="redirect-X" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents the next 1 damage dealt to this card
			until end of turn. 
			Example : {{{mtg/cards/Ordruun\_Commando.html}Ordruun Commando}}
			| Prévient le prochain dommage infligé à cette carte 
			jusqu'à la fin du tour.
			Exemple : {{{mtg/cards/Ordruun\_Commando.html}Ordruun Commando}}
		-->
		<action reference-name="prevent-1-on-this">
			<create-ability>
				<save target="this" />
				<ability ref="prevent-1" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents all damages dealt to this card
			until end of turn. 
			Example : {{{mtg/cards/Deftblade\_Elite.html}Deftblade Elite}}
			| Prévient tous les dommages infligés à cette carte 
			jusqu'à la fin du tour.
			Exemple : {{{mtg/cards/Deftblade\_Elite.html}Deftblade Elite}}
		-->
		<action reference-name="prevent-all-on-this">
			<create-ability>
				<save target="this" />
				<ability ref="prevent-all" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents all damages dealt by this card
			until end of turn. 
			Example : {{{mtg/cards/Deftblade\_Elite.html}Deftblade Elite}}
			| Prévient tous les dommages infligés par cette carte 
			jusqu'à la fin du tour.
			Exemple : {{{mtg/cards/Deftblade\_Elite.html}Deftblade Elite}}
		-->
		<action reference-name="prevent-all-from-this">
			<create-ability>
				<save target="this" />
				<replacement-ability zone="play">
					<assigned-damage type="damage-can-be-prevented">
						<source-test>
							<is target="saved" />
						</source-test>
					</assigned-damage>
					<effects />
				</replacement-ability>
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents the next 1 damage dealt to the last target card
			until end of turn. 
			Example : {{{mtg/cards/Heal.html}Heal}}, {{{mtg/cards/Samite\_Healer.html}Samite Healer}}
			| Prévient le prochain dommage infligé à la dernière carte ciblée
			jusqu'à la fin du tour.
			Exemple : {{{mtg/cards/Heal.html}Heal}}, {{{mtg/cards/Samite\_Healer.html}Samite Healer}}
		-->
		<action reference-name="prevent-1">
			<create-ability>
				<save target="target-list.last" />
				<ability ref="prevent-1" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents the next 2 damage dealt to the last target card
			until end of turn. 
			Example : {{{mtg/cards/Elvish\_Healer.html}Elvish Healer}}
			| Prévient les 2 prochains dommages infligés à la dernière carte ciblée
			jusqu'à la fin du tour.
			Exemple : {{{mtg/cards/Elvish\_Healer.html}Elvish Healer}}
		-->
		<action reference-name="prevent-2">
			<create-ability>
				<save target="target-list.last" />
				<ability ref="prevent-2" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents the next 3 damage dealt to the last target card
			until end of turn. 
			Example : {{{mtg/cards/Healing\_Salve.html}Healing Salve}}
			| Prévient les 3 prochains dommages infligés à la dernière carte ciblée
			jusqu'à la fin du tour.
			Exemple : {{{mtg/cards/Healing\_Salve.html}Healing Salve}}
		-->
		<action reference-name="prevent-3">
			<create-ability>
				<save target="target-list.last" />
				<ability ref="prevent-3" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents the next 4 damage dealt to the last target card
			until end of turn. 
			Example : {{{mtg/cards/Hallowed\_Healer.html}Hallowed Healer}}
			| Prévient les 4 prochains dommages infligés à la dernière carte ciblée
			jusqu'à la fin du tour.
			Exemple : {{{mtg/cards/Hallowed\_Healer.html}Hallowed Healer}}
		-->
		<action reference-name="prevent-4">
			<create-ability>
				<save target="target-list.last" />
				<ability ref="prevent-4" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents the next 5 damage dealt to the last target card
			until end of turn. 
			Example : {{{mtg/cards/Abunas\_Chant.html}Abuna's Chant}}
			| Prévient les 5 prochains dommages infligés à la dernière carte ciblée
			jusqu'à la fin du tour.
			Exemple : {{{mtg/cards/Abunas\_Chant.html}Abuna's Chant}}
		-->
		<action reference-name="prevent-5">
			<create-ability>
				<save target="target-list.last" />
				<ability ref="prevent-5" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents the next 6 damage dealt to the last target card
			until end of turn. 
			Example : {{{mtg/cards/Recuperate.html}Recuperate}}
			| Prévient les 6 prochains dommages infligés à la dernière carte ciblée
			jusqu'à la fin du tour.
			Exemple : {{{mtg/cards/Recuperate.html}Recuperate}}
		-->
		<action reference-name="prevent-6">
			<create-ability>
				<save target="target-list.last" />
				<ability ref="prevent-6" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents the next X damage dealt to the last target card
			until end of turn. 
			Example : {{{mtg/cards/Alabaster\_Potion.html}Alabaster Potion}}
			| Prévient les X prochains dommages infligés à la dernière carte ciblée
			jusqu'à la fin du tour.
			Exemple : {{{mtg/cards/Alabaster\_Potion.html}Alabaster Potion}}
		-->
		<action reference-name="prevent-x">
			<create-ability>
				<registers>
					<register index="0">
						<value register="stack" index="0" />
					</register>
				</registers>
				<save target="target-list.last" />
				<ability ref="prevent-x" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents all damage dealt to the last target card
			until end of turn. 
			Example : {{{mtg/cards/Circle\_of\_Protection\_Black.html}Circle of Protection: Black}}
			| Prévient tous les dommages infligés à la dernière carte ciblée
			jusqu'à la fin du tour.
			Exemple : {{{mtg/cards/Circle\_of\_Protection\_Black.html}Circle of Protection: Black}}
		-->
		<action reference-name="prevent-all">
			<create-ability>
				<save target="target-list.last" />
				<ability ref="prevent-all" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents all combat damage dealt to the last target card
			until end of turn. 
		-->
		<action reference-name="prevent-all-combat-on-target">
			<create-ability>
				<save target="target-list.last" />
				<ability ref="prevent-all-combat-on-target" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents all damages dealt by the last target card
			until end of turn. 
			
			| Prévient tous les dommages infligés par la dernière carte 
			jusqu'à la fin du tour.
		-->
		<action reference-name="prevent-all-from">
			<create-ability>
				<save target="target-list.last" />
				<replacement-ability zone="play">
					<assigned-damage type="damage-can-be-prevented">
						<source-test>
							<is target="saved" />
						</source-test>
					</assigned-damage>
					<effects />
				</replacement-ability>
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents all combat damage this turn.
			Example : {{{mtg/cards/Moments\_Peace.html}Moment's Peace}}
			| Prévient tous les dommages de combat infligés ce tour-ci.
			Exemple : {{{mtg/cards/Moments\_Peace.html}Moment's Peace}}
		-->
		<action reference-name="prevent-all-combat-damage">
			<create-ability>
				<replacement-ability zone="play">
					<assigned-damage type="damage-combat-can-be-prevented" />
					<effects />
				</replacement-ability>
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents all the combat damages that would be assigned
			by the first target this turn. |
			Prévient tous les dommages de combats qui aurait dus
			être infligés par la première cible ce tour-ci.
		-->
		<action reference-name="deals-no-combat-damage">
			<create-ability>
				<save target="target-list.first" />
				<ability ref="deals-no-combat-damage" />
				<until>
					<end-of-phase phase="cleanup" />
				</until>
			</create-ability>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Put in play this card under owner's control.
			| Met en jeu cette carte sous le contrôle du propriétaire.
		-->
		<action reference-name="put-in-play">
			<target-list operation="clear" name="%" />
			<target type="this" name="%" />
			<move-card controller="target.owner" destination="play" name="" />
		</action>

		<!--[[apt lang=en @reference-name]]
			Move target cards to play under owner's control.
		-->
		<action reference-name="move-to-play">
			<move-card controller="target.owner" destination="play" name="" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Chooses a card that could damage something.
			Example : {{{mtg/cards/Circle\_of\_Protection\_Black.html}Circle of Protection: Black}}
			| Choisis une carte qui pourrait faire des dommages à quelque chose.
			Exemple : {{{mtg/cards/Circle\_of\_Protection\_Black.html}Circle of Protection: Black}}
		-->
		<action reference-name="choose-damage-source">
			<target type="card" raise-event="false" cancel="false">
				<test ref="valid-damage-source" />
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Active the buyback option for the current spell.
			Example : {{{mtg/cards/Constant\_Mists.html}Constant Mists}}
			| Active l'option rappel pour le sort courant.
			Exemple : {{{mtg/cards/Constant\_Mists.html}Constant Mists}}
		-->
		<action reference-name="buyback">
			<modify-register register="this" index="special-abilities" operation="or"
				value="buyback-used" name="buyback" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Active the flashback option for the current spell.
			Example : {{{mtg/cards/Moments\_Peace.html}Moment's Peace}}
			| Active l'option flashback pour le sort courant.
			Exemple : {{{mtg/cards/Moments\_Peace.html}Moment's Peace}}
		-->
		<action reference-name="flashback">
			<target-list operation="clear" name="%" />
			<target type="this" name="%" />
			<action ref="remove-from-game" name="%" />
			<modify-register register="this" index="special-abilities" operation="or"
				value="flashback-used" name="flashback" />
		</action>

		<!-- 
			502.21a Kicker is a static ability that functions while the spell is on the 
			stack. "Kicker [cost]" means "You may pay an additional [cost] as you play 
			this spell." The phrase "Kicker [cost 1] and/or [cost 2]" means the same 
			thing as "Kicker [cost 1], kicker [cost 2]." Paying a spell's kicker 
			cost(s) follows the rules for paying additional costs in rules 409.1b and 
			409.1f-h.
			
			502.21b Objects with kicker have additional abilities that specify what 
			happens if the kicker cost is paid. Objects with more than one kicker cost 
			have abilities that correspond to each kicker cost.
			
			502.21c If the text that depends on a kicker cost being paid targets one or 
			more permanents and/or players, the spell's controller chooses those targets 
			only if he or she declared the intention to pay the appropriate kicker cost. 
			Otherwise, the targets aren't chosen at all.
			
			502.21d A card with kicker may contain the phrases "if the [A] kicker cost 
			was paid" and "if the [B] kicker cost was paid," where A and B are the first 
			and second kicker costs listed on the card, respectively. This text just 
			refers to one kicker cost or the other, regardless of what the spell's 
			controller actually spent when paying the cost. In other words, read "if 
			the [A] kicker cost was paid" as "if the first kicker cost listed was paid," 
			and read "if the [B] kicker cost was paid" as "if the second kicker cost 
			listed was paid."
		-->

		<!--[[apt lang=en|fr @reference-name]]
			Active the first kicker option for the current spell.
			Example : {{{mtg/cards/Duskwalker.html}Duskwalker}}
			| Active l'option kick pour le sort courant.
			Exemple : {{{mtg/cards/Duskwalker.html}Duskwalker}}
		-->
		<action reference-name="kicker">
			<modify-register register="this" index="special-abilities" operation="or"
				value="kicker-used" name="kicker" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Active the first kicker option for the current spell.
			Example : {{{mtg/cards/Cetavolver.html}Cetavolver}}
			| Active l'option kick pour le sort courant.
			Exemple : {{{mtg/cards/Cetavolver.html}Cetavolver}}
		-->
		<action reference-name="kicker2">
			<modify-register register="this" index="special-abilities" operation="or"
				value="kicker2-used" name="kicker2" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Active the first entwine option for the current spell.
			Example : {{{mtg/cards/Dreams\_Grip.html}Dream's Grip}}
			| Active l'option entwine pour le sort courant.
			Exemple : {{{mtg/cards/Dreams\_Grip.html}Dream's\ Grip}}
		-->
		<action reference-name="entwine">
			<modify-register register="this" index="special-abilities" operation="or"
				value="entwine-used" name="entwine" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			change the planeswalker index to used.
			Example : {{{mtg/cards/Jace\_Beleren.html}Jace Beleren}}
		-->
		<action reference-name="planeswalker-ability-used">
			<modify-register register="this" index="planeswalker-ability" operation="set"
				value="1" name="planeswalker-ability-used" />
		</action>

		<!--
			502.12. Rampage
			502.12a Rampage is a triggered ability. "Rampage X" means "Whenever this
			creature becomes blocked, it gets +X/+X until end of turn for each
			creature blocking it beyond the first." (See rule 309, "
			Blockers Step.")
			502.12b The rampage bonus is calculated only once per combat, when the
			triggered ability resolves. Adding or removing blockers later in
			combat won't change the bonus.
			502.12c If a creature has multiple instances of rampage, each triggers
			separately.
		-->
		<action reference-name="priv_prepare-rampage">
			<!--
				WHILE (association {me -> defending creature} found) -->
			<modify-register register="stack" index="0" operation="clear" />
			<modify-register register="stack" index="1" operation="set">
				<value register="game.static" index="assignment-configuration" />
			</modify-register>
			<!--
				DO ( search "this" in the association list) -->
			<modify-register register="stack" index="1" operation="set">
				<value>
					<target-list operation="index-of-saved-list" target="this">
						<list-index register="stack" index="1" />
					</target-list>
				</value>
			</modify-register>
			<!--
				IF (attacking creature has been found) -->
			<if-then-hop elsehop="4">
				<test>
					<different right="-1">
						<left register="stack" index="1" />
					</different>
				</test>
			</if-then-hop>
			<!--
				THEN (increment counter and continue) -->
			<modify-register register="stack" index="0" operation="add" value="1" />
			<modify-register register="stack" index="1" operation="add" value="1" />
			<hop value="-4" />
			<!--
				ELSE (break)
				END IF
				END WHILE
				
				IF (several creatures are blocking this creature) -->
			<if-then-hop elsehop="3">
				<test>
					<sup right="1">
						<left register="stack" index="0" />
					</sup>
				</test>
			</if-then-hop>
			<!--
				THEN ( Add +X/+X) -->
			<target type="this" />
			<modify-register register="stack" index="0" operation="minus" value="1" />
			<!--
				... see 'priv_do-rampage' -->
		</action>
		<action reference-name="priv_do-rampage">
			<!--
				... see 'priv_prepare-rampage' -->
			<modify-register register="stack" index="0" operation="mult" />
			<!-- rampage value? -->
			<add-modifier>
				<register-modifier index="power" operation="add" linked="false"
					live-update="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
					<value register="stack" index="0" />
				</register-modifier>
				<register-modifier index="toughness" operation="add" linked="false"
					live-update="false">
					<until>
						<end-of-phase phase="cleanup" />
					</until>
					<value register="stack" index="0" />
				</register-modifier>
			</add-modifier>
			<!--
				END IF -->
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Makes the owner of the current card skip his next turn. |
			Fais passer son prochain tour au propriétaire de la carte courante.
		-->
		<action reference-name="skip-next-turn">
			<create-ability name="skip-turn">
				<ability ref="skip-next-turn" />
			</create-ability>
		</action>

		<!--  212.2h (...) Control of the creature matters only when
			the equip ability is played and resolved. -->
		<!--[[apt lang=en|fr @reference-name]]
			Targets a creature could be equiped by the current card.
			Example : {{{mtg/cards/Grifters\_Blade.html}Grifter's Blade}}
			| Cible une créture qui peut être équipée par la carte courante.
			Exemple : {{{mtg/cards/Grifters\_Blade.html}Grifter's Blade}}
		-->
		<action reference-name="target-equipable-creature">
			<target type="card" mode="choose" restriction-zone="play">
				<test>
					<valid-attachment from="this" card="tested" />
				</test>
			</target>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Equips the last target with the current card (that should be
			an <equipment>). |
			Equipe la dernière cible avec la carte courante (qui devrait
			être alors un <équipement>).
		-->
		<action reference-name="equip">
			<if-then-hop elsehop="abortme">
				<test>
					<controller player="tested" card="target-list.first" />
				</test>
			</if-then-hop>
			<attach from="this" to="target-list.last" />
		</action>

		<!-- Radiance - ... target creature and each other creature that shares
			a color with it....
			The first target is supposed to be already added to the target-list at index 0.
			The valid targets are added to the target-list.
		-->
		<!--[[apt lang=en|fr @reference-name]]
			<Radiance> option implementation.
			Example : {{{mtg/cards/Rally\_the\_Righteous.html}Rally the Righteous}}
			| Implémentation de l'option <radiance>.
			Exemple : {{{mtg/cards/Rally\_the\_Righteous.html}Rally the Righteous}}
		-->
		<action reference-name="radiance">
			<target mode="all" type="card" restriction-zone="play" name="radiance">
				<test>
					<and>
						<not>
							<is target="target-list.first" />
						</not>
						<different right="0">
							<left>
								<and>
									<left>
										<card-colors card="tested" />
									</left>
									<right>
										<card-colors card="target-list.first" />
									</right>
								</and>
							</left>
						</different>
					</and>
				</test>
			</target>
		</action>

		<!--
			502.26. Morph
			502.26a Morph is a static ability that functions in any zone from which
			you could play the card it's on, and the morph effect works any time the
			card is face down. "Morph [cost]" means "You may play this card as a 2/2
			face-down creature, with no text, no name, no subtypes, no expansion
			symbol, and no mana cost by paying {3} rather than its mana cost."
			Any time you could play an instant, you may show all players the morph
			cost for any face-down permanent you control, pay that cost, then turn
			the permanent face up. This action does not use the stack. (See rule
			504, "Face-Down Spells and Permanents.")
			502.26b To play a card using its morph ability, turn it face down. It
			becomes a 2/2 face-down creature card, with no text, no name, no
			subtypes, no expansion symbol, and no mana cost. These values are the
			copiable values of that object's characteristics. (See rule 418.5,
			"Interaction of Continuous Effects," and rule 503, "Copying Objects.")
			Put it onto the stack (as a face-down spell with the same characteristics),
			and pay {3} rather than pay its mana cost. This follows the rules for
			paying alternative costs. You can use morph to play a card from any
			zone from which you could normally play it. When the spell resolves,
			it comes into play with the same characteristics the spell had. The
			morph effect applies to the face-down object wherever it is, and it
			ends when the permanent is turned face up.
			502.26c You can't play a card face down if it doesn't have morph.
			502.26d Any time you could play an instant, you may turn a face-down
			permanent you control face up. To do this, show all players what the
			permanent's morph cost will be when the effect ends, pay that cost,
			then turn the permanent face up. The morph effect on it ends, and it
			regains its normal characteristics. Any abilities relating to the
			permanent coming into play don't trigger when it's turned face up and
			don't have any effect, because the permanent has already come into
			play.
			502.26e If a face-up permanent is turned face down by a spell or ability,
			it becomes a 2/2 face-down creature, with no text, no name, no
			subtypes, no expansion symbol, and no mana cost. These values are the
			copiable values of that object's characteristics. (See rule 418.5,
			"Interaction of Continuous Effects," and rule 503, "Copying Objects.")
			The rules for morph and face-down permanents apply to it normally.
			502.26f See rule 504, "Face-Down Spells and Permanents," for more
			information on how to play cards with morph.
		-->
		<!--[[apt lang=en|fr @reference-name]]
			<Morph> ability implementation : face up the card.
			Example : {{{mtg/cards/Aphetto\_Alchemist.html}Aphetto Alchemist}}
			| Implémentation de la capacité <mue> : retourne la carte courante face visible.
			Exemple : {{{mtg/cards/Aphetto\_Alchemist.html}Aphetto Alchemist}}
		-->
		<action reference-name="morph">
			<target-list operation="clear" />
			<target type="this" />
			<face-up for="everyone" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			This imprints the last target of target list into the card owning this action.
			The imprinted card is stored as 'private-object' component in the card. |
			Cette action imprime la dernière cible de la liste de cibles sur la carte 
			contrôlant cette action. La card imprimée est sauvegardée en tant que
			composant 'private-object' dans la carte.-->
		<action reference-name="imprint-card">
			<private-object object="target-list.last" object-name="imprinted-card" operation="add" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Load the imprinted card into the target list. If there is no imprinted card, 
			an error is thrown. Use the 'has-imprinted-card' test. |
			Charge la carte imprimée dans la liste de cibles. S'il n'y a pas de carte 
			imprimée, une erreur est générée. Utiliser le test 'has-imprinted-card'.-->
		<action reference-name="load-imprinted-card">
			<target type="private-object" name="imprinted-card" />
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Pay colorless X manas. Example : {{{mtg/cards/Fireball.html}Fireball}} |
			Paye X manas incolores. Exemple : {{{mtg/cards/Fireball.html}Fireball}}
		-->
		<action reference-name="pay-x">
			<input-number minimum="0" register="stack" index="0" operation="set" default="%maximum"
				strict-max="false">
				<text>%value-of-x</text>
				<maximum>
					<minus>
						<left register="controller" index="manapool" />
						<right register="required-mana" index="manapool" />
					</minus>
				</maximum>
			</input-number>
			<pay-mana>
				<colorless register="stack" index="0" />
			</pay-mana>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Pay colorless XX manas. Example :
			{{{mtg/cards/Decree\_of\_Justice.html}Decree of Justice}} |
			Payer XX manas incolores. Exemple :
			{{{mtg/cards/Decree\_of\_Justice.html}Decree of Justice}}
		-->
		<action reference-name="pay-xx">
			<input-number minimum="0" register="stack" index="0" operation="set" default="%maximum"
				strict-max="false">
				<text>%value-of-x</text>
				<maximum>
					<div-truncated right="2">
						<left>
							<minus>
								<left register="controller" index="manapool" />
								<right register="required-mana" index="manapool" />
							</minus>
						</left>
					</div-truncated>
				</maximum>
			</input-number>
			<pay-mana>
				<colorless register="stack" index="0" />
			</pay-mana>
			<pay-mana>
				<colorless register="stack" index="0" />
			</pay-mana>
		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Forces the last target to block the current card during the next combat if able. |
			Force la dernière cible à bloquer la carte courante durant le prochain combat s'il
			le peut.
		-->
		<action reference-name="blocks-this-if-able">
			<create-ability>
				<save target="target-list.last" target2="this" />
				<triggered-ability zone="play" resolution="hidden">
					<beginning-of-phase phase="declare-blocking">
						<test>
							<equal right="2">
								<left register="game.static" index="attack-step-index" />
							</equal>
						</test>
					</beginning-of-phase>
					<effects>
						<if-then-hop elsehop="2">
							<test>
								<and>
									<in-zone zone="play" card="saved" />
									<in-zone zone="play" card="saved2" />
									<replace-tested by="saved2" ref="tested-is-attacking" />
								</and>
							</test>
						</if-then-hop>
						<target-list operation="save" list-index="-1" target="saved" />
						<target-list operation="save" list-index="-1" target="saved2" />
						<unregister-this />
					</effects>
				</triggered-ability>
			</create-ability>

		</action>

		<!--[[apt lang=en|fr @reference-name]]
			Amplify <<MACRO(\[value\])>> action.
			Example : {{{mtg/cards/Daru\_Stinger.html}Daru Stinger}}
			| Action amplify <<MACRO(\[value\])>>.
			Exemple : {{{mtg/cards/Daru\_Stinger.html}Daru Stinger}}
		-->
		<action reference-name="amplify">
			<modify-register register="stack" index="0" operation="set">
				<!-- macro value ? -->
			</modify-register>
			<repeat value="all" />
			<target mode="choose" raise-event="false" restriction-zone="hand" type="card"
				cancel="true" hop="1" name="amplify-%n-">
				<test>
					<different right="0">
						<left>
							<card-properties operation="intersection.size" card="this"
								card2="tested" lower="FIRST_SUB_TYPE" higher="LAST_SUB_TYPE" />
						</left>
					</different>
				</test>
			</target>
			<modify-register register="stack" index="0" operation="mult" value="target-list.size" />
			<target-list operation="clear" name="%" />
			<target type="this" />
			<repeat>
				<value register="stack" index="0" />
			</repeat>
			<add-object object-name="+1/+1" />
			<target-list operation="clear" name="%" />
		</action>
		
		<!--[[apt lang=en|fr @reference-name]]
			501.10. Clash
			501.10a To clash, a player reveals the top card of his or her library. That player may then put that card on the bottom of his or her library.
			501.10b "Clash with an opponent" means "Choose an opponent. You and that opponent each clash."
			501.10c A player wins a clash if that player revealed a card with a higher converted mana cost than all other cards revealed in that clash.
			the Macro actions are the actions that occur if you win the clash.
			<<MACRO(\[actions\])>>
			Example : {{{mtg/cards/Adder\_Staff\_Boggart.html}Adder-Staff Boggart}}
		-->
		<action reference-name="clash">
			<target type="card" mode="all" restriction-zone="library">
				<test>
					<and>
						<controller player="you"/>
						<position position="top" />
					</and>
				</test>
			</target>
			<action ref="reveal"/>
			<choice controller="you" cancel="false">
				<either>
					<action ref="move-library-top"/>
				</either>
				<either>
					<action ref="move-library-bottom"/>
				</either>
			</choice>
			<modify-register register="stack" index="0" operation="set">
				<value register="target-list.last" index="manacost"/>
			</modify-register>
			<target-list operation="remove-last"/>
			<target type="card" mode="all" restriction-zone="library">
				<test>
					<and>
						<controller player="opponent"/>
						<position position="top" />
					</and>
				</test>
			</target>
			<action ref="reveal"/>
			<choice controller="opponent" cancel="false">
				<either>
					<action ref="move-library-top"/>
				</either>
				<either>
					<action ref="move-library-bottom"/>
				</either>
			</choice>
			<if-then-hop elsehop="3">
				<test>
					<sup>
						<left register="stack" index="0"/>
						<right register="target-list.last" index="manacost"/>
					</sup>
				</test>
			</if-then-hop>
			<macro>
				<default />
			</macro>
			<hop value="2"/>
			<macro>
				<default />
			</macro>
		</action>
	</actions>

	<!--[[apt lang=en]]
		** Abilities references
		
		`These are described within the nested <<<\<abilities\>>>> element. Using these
		`references is the best way to accelerate card developement and maintenance since
		`repetitive code are place in this place. So if you find some abilities appearing
		`often in cards, this is the right place to add a reference to share with the
		`community of card rules developers. The project team will make infinite effort
		`to add this ability detection in our card generator for the Oracle. Some abilities 
		`work as	macro by accepting one or two actions lists.
		`We can find the following references :
		
		*___________________________+__________________________________________________+
		| <<Reference name>>        | <<Description>>
		*___________________________+__________________________________________________+-->
	<!--[[apt lang=fr]]
		** Les références de capacités
		
		`Elles sont décrites au sein de l'élément <<<\<abilities\>>>>. Utiliser ces
		`références est la meilleure manière d'accélérer le développement et la
		`maintenance du code des cartes car elles centralisent tout le code réutilisable
		`relatif aux cartes. Ainsi, si vous trouvez des capacités souvent répétées
		`dans les cartes, c'est le meilleur endroit pour y ajouter une référence afin de
		`la partager avec l'ensemble de la communauté des développeurs de cartes.
		`L'équipe de développement fera tout son possible pour inclure la détection
		`de nouvelles capacités au sein de son générateur de règles de cartes à partir de
		`l'Oracle. Certaines capacités fonctionnent comme des macros en acceptant une 
		`ou deux liste d'actions.
		`On trouve les références suivantes :
		
		*___________________________+__________________________________________________+
		| <<Nom de la référence>>   | <<Description>>
		*___________________________+__________________________________________________+-->

	<abilities>
		<!--[[apt parse-card=Lotus_Bloom]]-->
		<!--[[apt parse-card=Adder_Staff_Boggart]]-->
		<!--[[apt parse-card=Decree_of_Justice]]-->
		<!--[[apt parse-card=Fireball]]-->
		<!--[[apt parse-card=Aphetto_Alchemist]]-->
		<!--[[apt parse-card=Rally_the_Righteous]]-->
		<!--[[apt parse-card=Grifters_Blade]]-->
		<!--[[apt parse-card=Jace_Beleren]]-->
		<!--[[apt parse-card=Cetavolver]]-->
		<!--[[apt parse-card=Dreams_Grip]]-->
		<!--[[apt parse-card=Duskwalker]]-->
		<!--[[apt parse-card=Constant_Mists]]-->
		<!--[[apt parse-card=Moments_Peace]]-->
		<!--[[apt parse-card=Circle_of_Protection_Black]]-->
		<!--[[apt parse-card=Alabaster_Potion]]-->
		<!--[[apt parse-card=Recuperate]]-->
		<!--[[apt parse-card=Abunas_Chant]]-->
		<!--[[apt parse-card=Hallowed_Healer]]-->
		<!--[[apt parse-card=Healing_Salve]]-->
		<!--[[apt parse-card=Elvish_Healer]]-->
		<!--[[apt parse-card=Samite_Healer]]-->
		<!--[[apt parse-card=Deftblade_Elite]]-->
		<!--[[apt parse-card=Ordruun_Commando]]-->
		<!--[[apt parse-card=Daughter_of_Autumn]]-->
		<!--[[apt parse-card=Nomads_en_Kor]]-->
		<!--[[apt parse-card=Heal]]-->
		<!--[[apt parse-card=Bandage]]-->
		<!--[[apt parse-card=Blades_of_Velis_Vel]]-->
		<!--[[apt parse-card=Raka_Disciple]]-->
		<!--[[apt parse-card=Ivory_Charm]]-->
		<!--[[apt parse-card=Dross_Golem]]-->
		<!--[[apt parse-card=Daru_Stinger]]-->
		<!--[[apt parse-card=Unstable_Shapeshifter]]-->
		<!--[[apt parse-card=Dragon_Whelp]]-->
		<!--[[apt parse-card=Teekas_Dragon]]-->
		<!--[[apt parse-card=Sunfire_Balm]]-->
		<!--[[apt parse-card=Bloodscale_Prowler]]-->
		<!--[[apt parse-card=AEthersnipe]]-->
		<!--[[apt parse-card=Scab_Clan_Mauler]]-->
		<!--[[apt parse-card=Ghor_Clan_Savage]]-->
		<!--[[apt parse-card=Grave_Shell_Scarab]]-->
		<!--[[apt parse-card=Darkblast]]-->
		<!--[[apt parse-card=Perplex]]-->
		<!--[[apt parse-card=Craw_Giant]]-->
		<!--[[apt parse-card=Balduvian_War_Makers]]-->
		<!--[[apt lang=en|fr @reference-name]]
			Trigerred ability relative to the management of the <suspend> 
			ability. It is used by the <<<cast-suspend>>> ability.
			The ability triggers at the beginning of your upkeep and remove
			one <time> mark from the card that reference this ability then
			if there is no more <time> mark on this card, it is put into
			play. TODO : the card must be considered to have been played
			during the turn when the card has been put into play and not
			during the turn when the <suspend> ability has been cast, this
			information is relevant for all cards that use the <storm> ability.
			An example of the use of this ability is available
			throught the {{{mtg/cards/Lotus\_Bloom.html}Lotus Bloom}} card. |
			Capacité déclenchée relative à la gestion de la <suspension>.
			Elle est utilisée par l'abilité <<<cast-suspend>>>.
			La capacité se déclenche au début de votre phase d'entretien et
			a pour effet de retirer un marquer <temps> sur la carte
			référençant cette abilité, s'il ne reste plus de marqueur
			<temps> sur cette carte, elle est mise en jeu. TODO : il faut
			que la carte soit considérée comme <jouée> durant le tour où
			elle a été mise en jeu et pas pendant le tour où la capacité de
			<suspension> a été invoquée, cette information a de l'importance
			pour toutes les cartes exploitant le mécanis-this <déluge>.
			Un exemple de l'utilisation de cette capacité est disponible à
			travers la carte {{{mtg/cards/Lotus\_Bloom.html}Lotus Bloom}}. -->
		<ability reference-name="suspend">
			<triggered-ability zone="side">
				<beginning-of-phase phase="upkeep">
					<test>
						<and>
							<test ref="during-your-upkeep" />
							<sup-equal right="1">
								<left>
									<counter object-name="time" card="this" />
								</left>
							</sup-equal>
						</and>
					</test>
				</beginning-of-phase>
				<effects>
					<!-- intervening if, needs to check during trigger and during resolution -->
					<if-then-hop elsehop="abortme">
						<test>
							<sup-equal right="1">
								<left>
									<counter object-name="time" card="this" />
								</left>
							</sup-equal>
						</test>
					</if-then-hop>
					<target type="this" />
					<remove-object object-name="time" />
					<if-then-hop elsehop="abortme">
						<test>
							<equal right="0">
								<left>
									<counter object-name="time" card="this" />
								</left>
							</equal>
						</test>
					</if-then-hop>
					<modify-register register="this" index="special-abilities" operation="or"
						value="suspend-triggered" />
				</effects>
			</triggered-ability>
		</ability>

		<ability reference-name="suspend-trigger">
			<triggered-ability zone="side">
				<modified-register operation="or" register="card" index="special-abilities">
					<destination-test>
						<and>
							<is-this />
							<equal left="suspend-triggered">
								<right>
									<and left="suspend-triggered">
										<right register="this" index="special-abilities" />
									</and>
								</right>
							</equal>
						</and>
					</destination-test>
				</modified-register>
				<effects>
					<target-list operation="clear" />
					<target type="you" />
					<force-play must-be-played="true" hop="2">
						<card-test>
							<and>
								<in-zone zone="side" />
								<is-this />
							</and>
						</card-test>
						<ability-test>
							<playable-ability idcard="instant" />
						</ability-test>
					</force-play>
					<hop value="-1" />
					<unregister-this />
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			<<MACRO(actions, actions)>> : this activated ability must be
			referenced by any card using the <suspend> ability. It allows
			the owner of the card to cast the spell associated through the
			<suspension> mode and dynamically  add to the removed from the
			game card the <<<suspend>>> trigerred ability. The first <<<\<actions\>>>>
			macro is used to specify the cost of the <suspend> ability.
			The second <<<\<actions\>>>> is called after removing the card from the
			game and allows you to implement the addition of <time> marks
			to the card removed from the game. An example of the use of this
			ability is available through the
			{{{mtg/cards/Lotus\_Bloom.html}Lotus Bloom}} card. |
			<<MACRO(actions, actions)>> : cette capacité activée doit
			être référencée par toute carte exploitant la capacité <suspension>.
			Il permet au possesseur de la carte d'invoquer le sort associé
			en mode <suspension> et ajoute de manière dynamique la capacité
			déclenchée <<<suspend>>> à la carte retirée du jeu.
			La première <<<\<actions\>>>> macro permet de spécifier le coût de la
			capacité de suspension. La seconde <<<\<actions\>>>> macro est appelée
			juste après avoir retiré la carte du jeu et vous permet d'implémenter
			l'ajout de marqueur <temps> sur la carte retirée du jeu.
			Un exemple de l'utilisation de cette capacité est disponible à
			travers la carte {{{mtg/cards/Lotus\_Bloom.html}Lotus Bloom}}. -->
		<ability reference-name="cast-suspend">
			<activated-ability zone="hand" playable="this" play-as-spell="false"
				resolution="auto">
				<cost>
					<macro>
						<default />
					</macro>
				</cost>
				<effects>
					<target-list operation="clear" />
					<target type="this" />
					<action ref="remove-from-game" />
					<macro>
						<default />
					</macro>
					<target-list operation="clear" />
					<target type="this" />
					<add-modifier>
						<ability-modifier linked="false" operation="add" layer="global">
							<abilities>
								<ability ref="suspend" />
								<ability ref="suspend-trigger" />
								<activated-ability name="suspend-play" playable="instant"
									zone="side">
									<test>
										<and>
											<test ref="during-your-upkeep"/>
											<equal left="suspend-triggered">
												<right>
													<and left="suspend-triggered">
														<right register="this"
															index="special-abilities" />
													</and>
												</right>
											</equal>
										</and>
									</test>
									<cost>
										<macro>
											<default />
										</macro>
									</cost>
									<effects>
										<macro>
											<default>
												<action ref="put-in-play" />
											</default>
										</macro>
									</effects>
								</activated-ability>
							</abilities>
						</ability-modifier>
					</add-modifier>
				</effects>
			</activated-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Provoke trigger implementation. |
			Implémentation de Provocation.-->
		<!-- 
			500.5 - When determining what requirements could be obeyed without 
			violating restrictions, you don't need to consider any options for a 
			creature that don't satisfy a requirement on it. But you do need to 
			consider any options for any creature(s) that will satisfy a requirement, 
			as long as the total number of obeyed requirements is increased (even if 
			the option means not obeying another requirement that was previously 
			met). [CompRules 2003/10/01]
			
			TODO Example: A player controls one creature that "blocks if able" and 
			another creature with no abilities. An effect states, "Creatures can't 
			be blocked except by two or more creatures." The creature with no 
			abilities isn't required to block. It's legal to declare both creatures 
			as blockers, or to declare neither creature as a blocker, but illegal to 
			block with only one of the two. [CompRules 2003/07/01] 
			
			TODO 500.Ruling.1 - As a side-effect of these rules, if one creature has 
			two copies of Lure on it and another creature has one copy of Lure on it, 
			then blockers must block the one with two Lures if possible, because 
			that blocking assignment satisfies two requirements instead of just one. 
			[Barclary 2003/12/11]			
		-->
		<ability reference-name="provoke">
			<triggered-ability zone="play">
				<declared-attacking>
					<test>
						<is-this />
					</test>
				</declared-attacking>
				<cost>
					<target type="card" mode="choose" restriction-zone="play" cancel="true"
						hop="abortme">
						<test>
							<and>
								<test ref="valid-creature-to-enchant" />
								<controller player="currentplayer.opponent" />
							</and>
						</test>
					</target>
				</cost>
				<effects>
					<untap />
					<action ref="blocks-this-if-able" />
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Graft trigger implementation. Moves a +1/+1 counter from this to a card 
			coming into play. |
			Implémentation de Graft. Déplace un compteur +1/+1 de cette carte vers 
			la carte qui arrive en jeu.-->
		<ability reference-name="graft">
			<triggered-ability zone="play">
				<moved-card>
					<source-test>
						<and>
							<not>
								<is-this />
							</not>
							<not>
								<in-zone zone="play" />
							</not>
							<has-idcard idcard="creature" />
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="play" />
					</destination-test>
				</moved-card>
				<effects>
					<choice controller="you" cancel="true">
						<either>
							<target type="this" />
							<remove-object object-name="+1/+1" />
							<target-list operation="clear" />
							<target type="context.card" />
							<add-object object-name="+1/+1" />
						</either>
					</choice>
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en @reference-name]]
			Modular trigger implementation. Moves counters from <this> card to
			target artifact creature |
		-->
		<ability reference-name="modular">
			<triggered-ability zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<in-zone zone="play" />
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="graveyard" />
					</destination-test>
				</moved-card>
				<cost>
					<action ref="target-artifact-creature" />
				</cost>
				<effects>
					<choice controller="you" cancel="true">
						<either>
							<repeat>
								<value>
									<counter object-name="+1/+1" card="context.card" />
								</value>
							</repeat>
							<add-object object-name="+1/+1" />
						</either>
					</choice>
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en @reference-name]]
			502.39. Soulshift
			502.39a Soulshift is a triggered ability. "Soulshift N" means "When this permanent is put into a graveyard from play, 
			you may return target Spirit card with converted mana cost N or less from your graveyard to your hand."
			502.39b If a permanent has multiple instances of soulshift, each triggers separately.
		-->
		<ability reference-name="soulshift1">
			<triggered-ability zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<in-zone zone="play" />
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="graveyard" />
					</destination-test>
				</moved-card>
				<cost>
					<target type="card" mode="choose" raise-event="true"
						restriction-zone="graveyard">
						<test>
							<and>
								<controller player="you" />
								<has-property property="spirit" />
								<inf-equal right="1">
									<left register="tested" index="manacost" />
								</inf-equal>
							</and>
						</test>
					</target>
				</cost>
				<effects>
					<choice controller="you" cancel="true">
						<either>
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</triggered-ability>
		</ability>

		<ability reference-name="soulshift2">
			<triggered-ability zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<in-zone zone="play" />
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="graveyard" />
					</destination-test>
				</moved-card>
				<cost>
					<target type="card" mode="choose" raise-event="true"
						restriction-zone="graveyard">
						<test>
							<and>
								<controller player="you" />
								<has-property property="spirit" />
								<inf-equal right="2">
									<left register="tested" index="manacost" />
								</inf-equal>
							</and>
						</test>
					</target>
				</cost>
				<effects>
					<choice controller="you" cancel="true">
						<either>
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</triggered-ability>
		</ability>

		<ability reference-name="soulshift3">
			<triggered-ability zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<in-zone zone="play" />
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="graveyard" />
					</destination-test>
				</moved-card>
				<cost>
					<target type="card" mode="choose" raise-event="true"
						restriction-zone="graveyard">
						<test>
							<and>
								<controller player="you" />
								<has-property property="spirit" />
								<inf-equal right="3">
									<left register="tested" index="manacost" />
								</inf-equal>
							</and>
						</test>
					</target>
				</cost>
				<effects>
					<choice controller="you" cancel="true">
						<either>
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</triggered-ability>
		</ability>

		<ability reference-name="soulshift4">
			<triggered-ability zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<in-zone zone="play" />
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="graveyard" />
					</destination-test>
				</moved-card>
				<cost>
					<target type="card" mode="choose" raise-event="true"
						restriction-zone="graveyard">
						<test>
							<and>
								<controller player="you" />
								<has-property property="spirit" />
								<inf-equal right="4">
									<left register="tested" index="manacost" />
								</inf-equal>
							</and>
						</test>
					</target>
				</cost>
				<effects>
					<choice controller="you" cancel="true">
						<either>
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</triggered-ability>
		</ability>

		<ability reference-name="soulshift5">
			<triggered-ability zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<in-zone zone="play" />
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="graveyard" />
					</destination-test>
				</moved-card>
				<cost>
					<target type="card" mode="choose" raise-event="true"
						restriction-zone="graveyard">
						<test>
							<and>
								<controller player="you" />
								<has-property property="spirit" />
								<inf-equal right="5">
									<left register="tested" index="manacost" />
								</inf-equal>
							</and>
						</test>
					</target>
				</cost>
				<effects>
					<choice controller="you" cancel="true">
						<either>
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</triggered-ability>
		</ability>

		<ability reference-name="soulshift6">
			<triggered-ability zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<in-zone zone="play" />
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="graveyard" />
					</destination-test>
				</moved-card>
				<cost>
					<target type="card" mode="choose" raise-event="true"
						restriction-zone="graveyard">
						<test>
							<and>
								<controller player="you" />
								<has-property property="spirit" />
								<inf-equal right="6">
									<left register="tested" index="manacost" />
								</inf-equal>
							</and>
						</test>
					</target>
				</cost>
				<effects>
					<choice controller="you" cancel="true">
						<either>
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</triggered-ability>
		</ability>

		<ability reference-name="soulshift7">
			<triggered-ability zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<in-zone zone="play" />
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="graveyard" />
					</destination-test>
				</moved-card>
				<cost>
					<target type="card" mode="choose" raise-event="true"
						restriction-zone="graveyard">
						<test>
							<and>
								<controller player="you" />
								<has-property property="spirit" />
								<inf-equal right="7">
									<left register="tested" index="manacost" />
								</inf-equal>
							</and>
						</test>
					</target>
				</cost>
				<effects>
					<choice controller="you" cancel="true">
						<either>
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</triggered-ability>
		</ability>

		<ability reference-name="soulshift8">
			<triggered-ability zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<in-zone zone="play" />
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="graveyard" />
					</destination-test>
				</moved-card>
				<cost>
					<target type="card" mode="choose" raise-event="true"
						restriction-zone="graveyard">
						<test>
							<and>
								<controller player="you" />
								<has-property property="spirit" />
								<inf-equal right="8">
									<left register="tested" index="manacost" />
								</inf-equal>
							</and>
						</test>
					</target>
				</cost>
				<effects>
					<choice controller="you" cancel="true">
						<either>
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en @reference-name]]
			Madness implementation. "If you discard this card, you may play it 
			for its madness cost instead of putting it into your graveyard."
			The way it is implemented it may be bugged with "samurai of the pale curtain"
			or "leyline of the void" in play.
			It may have problems with "Teferi" when it is created and with "Storm" ability counter.
			It needs an action for the madness cost on parameter and another action for the spell effect.
		-->
		<ability reference-name="madness">
			<triggered-ability zone="hand">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<in-zone zone="hand" />
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="graveyard" />
					</destination-test>
				</moved-card>
				<cost>
					<macro>
						<default />
					</macro>
				</cost>
				<effects>
					<choice controller="you" cancel="true">
						<either>
							<macro>
								<default />
							</macro>
							<macro>
								<default>
									<action ref="put-in-play" />
								</default>
							</macro>
						</either>
					</choice>
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Moves the card referencing this action to its owner's graveyard,
			and allows the card's owner to draw a card from its library. This ability
			is a macro, an actions list must be provided as parameter. 
			Example : {{{mtg/cards/Sunfire\_Balm.html}Sunfire Balm}}
			| Déplace la carte qui référence cette action dans le cimetière de
			son propriétaire et permet à ce même propriétaire de piocher une
			carte depuis sa bibliothèque. Cette capacité est une macro, une liste 
			d'action doit être donnée en paramètre 
			Exemple : {{{mtg/cards/Sunfire\_Balm.html}Sunfire Balm}}
		-->
		<ability reference-name="cycling">
			<activated-ability playable="instant" zone="hand">
				<cost>
					<macro>
						<default />
					</macro>
				</cost>
				<effects>
					<macro>
						<default />
					</macro>
					<!-- TODO instead use target-index feature when implemented -->
					<target-list operation="clear" name="%" />
					<target type="this" name="%" />
					<action ref="put-in-graveyard" name="cycling" />
					<target-list operation="clear" name="%" />
					<target type="you" name="%" />
					<action ref="draw-a-card" name="%" />
				</effects>
			</activated-ability>
		</ability>
		
		<!--[[apt lang=en @reference-name]]
			Evoke is an alternative cost. Playing a creature by paying its evoke cost 
			rather than its mana cost causes that creature to be sacrificed 
			when it comes into play. 
			Example : {{{mtg/cards/AEthersnipe}AEthersnipe}}
		-->
		<ability reference-name="evoke">
			<activated-ability playable="sorcery" zone="hand">
				<cost>
					<macro>
						<default />
					</macro>
				</cost>
				<effects>
					<action ref="put-in-play"/>
					<action ref="sacrifice-this"/>
				</effects>
			</activated-ability>
		</ability>

		<!--[[apt lang=en @reference-name]]
			Evoke is an alternative cost. Playing a creature by paying its evoke cost 
			rather than its mana cost causes that creature to be sacrificed 
			when it comes into play. 
			Example : {{{mtg/cards/AEthersnipe}AEthersnipe}}
		-->
		<ability reference-name="evoke-flash">
			<activated-ability playable="instant" zone="hand">
				<cost>
					<macro>
						<default />
					</macro>
				</cost>
				<effects>
					<action ref="put-in-play"/>
					<action ref="sacrifice-this"/>
				</effects>
			</activated-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Forecast \{macro actions\} : \{macro actions\}.
			| Forecast \{macro actions\} : \{macro actions\}. -->
		<ability reference-name="forecast">
			<activated-ability playable="instant" zone="hand" play-as-spell="false">
				<test>
					<and>
						<test ref="during-your-upkeep" />
						<test ref="once-each-turn" />
					</and>
				</test>
				<cost>
					<target type="this" name="%" />
					<face-up for="everyone" name="forecast" />
					<target-list operation="clear" name="%" />
					<macro>
						<default />
					</macro>
					<action ref="use-once-each-turn" />
				</cost>
				<effects>
					<macro>
						<default />
					</macro>
				</effects>
			</activated-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : add one black mana to your mana pool.
			| \{T\} : ajouter un mana noir à votre réserve de mana. -->
		<ability reference-name="tap-add-B">
			<activated-ability playable="mana-source" zone="play" resolution="auto">
				<cost>
					<action ref="T" />
				</cost>
				<effects>
					<give-mana black="1" />
				</effects>
			</activated-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : add one blue mana to your mana pool.
			| \{T\} : ajouter un mana blue à votre réserve de mana. -->
		<ability reference-name="tap-add-U">
			<activated-ability playable="mana-source" zone="play" resolution="auto">
				<cost>
					<action ref="T" />
				</cost>
				<effects>
					<give-mana blue="1" />
				</effects>
			</activated-ability>
		</ability>
		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : add one green mana to your mana pool.
			| \{T\} : ajouter un mana vert à votre réserve de mana. -->
		<ability reference-name="tap-add-G">
			<activated-ability playable="mana-source" zone="play" resolution="auto">
				<cost>
					<action ref="T" />
				</cost>
				<effects>
					<give-mana green="1" />
				</effects>
			</activated-ability>
		</ability>
		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : add one red mana to your mana pool.
			| \{T\} : ajouter un mana rouge à votre réserve de mana. -->
		<ability reference-name="tap-add-R">
			<activated-ability playable="mana-source" zone="play" resolution="auto">
				<cost>
					<action ref="T" />
				</cost>
				<effects>
					<give-mana red="1" />
				</effects>
			</activated-ability>
		</ability>
		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : add one white mana to your mana pool.
			| \{T\} : ajouter un mana blanc à votre réserve de mana. -->
		<ability reference-name="tap-add-W">
			<activated-ability playable="mana-source" zone="play" resolution="auto">
				<cost>
					<action ref="T" />
				</cost>
				<effects>
					<give-mana white="1" />
				</effects>
			</activated-ability>
		</ability>
		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : add one colorless mana to your mana pool.
			| \{T\} : ajouter un mana incolor à votre réserve de mana. -->
		<ability reference-name="tap-add-C">
			<activated-ability playable="mana-source" zone="play" resolution="auto">
				<cost>
					<action ref="T" />
				</cost>
				<effects>
					<give-mana colorless="1" />
				</effects>
			</activated-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : to put a local enchantment into play, attached to a valid permanent.
			| \{T\} : mettre en jeu un enchantement local, attaché à un permanent valide. -->
		<!--  -->
		<ability reference-name="cast-enchant">
			<activated-ability playable="this" name="" zone="hand">
				<cost>
					<pay-mana value="manacost" />
					<action ref="target-for-attachment" />
				</cost>
				<effects>
					<attach from="this" to="target-list.first" />
				</effects>
			</activated-ability>
		</ability>
		
		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : to put a local enchantment with flash into play, attached to a valid permanent.
			| \{T\} : mettre en jeu un enchantement local, attaché à un permanent valide. -->
		<!--  -->
		<ability reference-name="cast-enchant-flash">
			<activated-ability playable="instant" name="" zone="hand">
				<cost>
					<pay-mana value="manacost" />
					<action ref="target-for-attachment" />
				</cost>
				<effects>
					<attach from="this" to="target-list.first" />
				</effects>
			</activated-ability>
		</ability>
		
		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : to put in play a permanent, paying it's manacost.
			| \{T\} : mettre en jeu un permanent en payant son coût de mana. -->
		<ability reference-name="cast-spell">
			<activated-ability playable="this" zone="hand">
				<cost>
					<pay-mana value="manacost" />
					<macro>
						<default />
					</macro>
				</cost>
				<effects>
					<macro>
						<default />
					</macro>
					<action ref="put-in-play" />
				</effects>
			</activated-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Use morph ability.
			| Utilise la capacité de morph. -->
		<ability reference-name="morph">
			<activated-ability playable="instant" zone="play" resolution="auto" name="morph">
				<test>
					<not>
						<is-face-up card="this" />
					</not>
				</test>
				<cost>
					<macro>
						<default />
					</macro>
				</cost>
				<effects>
					<action ref="morph" />
				</effects>
			</activated-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : to put in play a morph card, paying 3.
			| \{T\} : mettre en jeu un morph en payant 3. -->
		<ability reference-name="cast-morph">
			<activated-ability playable="this" zone="hand">
				<cost>
					<target type="this" name="%" />
					<face-down for="opponent" />
					<pay-mana colorless="3" />
				</cost>
				<effects>
					<action ref="put-in-play" />
					<add-modifier>
						<property-modifier operation="add" property="morph" />
					</add-modifier>
				</effects>
			</activated-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : to put in play a permanent using flash ability, paying it's manacost.
			| \{T\} : mettre en jeu un permanent avec la cpacité de flash, et en 
			payan sont coût de mana. -->
		<ability reference-name="cast-flash">
			<activated-ability playable="instant" zone="hand">
				<cost>
					<pay-mana value="manacost" />
				</cost>
				<effects>
					<action ref="put-in-play" />
				</effects>
			</activated-ability>
		</ability>
		
		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : to play a land.
			| \{T\} : jouer un terrin. -->
		<ability reference-name="cast-land">
			<activated-ability playable="this" resolution="auto" zone="hand" name="play-land">
				<test>
					<sup right="0">
						<left register="currentplayer" index="land-remain-to-cast" />
					</sup>
				</test>
				<effects>
					<action ref="put-in-play" />
				</effects>
			</activated-ability>
		</ability>

		<!-- Flanking
			502.3a Flanking is a triggered ability that triggers during the
			blockers step. (See rule 309, " Blockers Step.")
			"Flanking" means "Whenever this creature becomes blocked by a
			creature without flanking, the blocking creature gets -1/-1
			until end of turn."
			502.3b If a creature has multiple instances of flanking, each
			triggers separately.
		-->
		<ability reference-name="flanking">
			<triggered-ability name="flanking" zone="play">
				<declared-blocking>
					<attacking-test>
						<is-this />
					</attacking-test>
					<blocking-test>
						<not>
							<has-ability name="flanking" card="tested" />
						</not>
					</blocking-test>
				</declared-blocking>
				<effects>
					<target type="context.card" />
					<action ref="add-1-1-until-eot" />
				</effects>
			</triggered-ability>
		</ability>
		<!-- Haunting
			502.51. Haunt
			502.51a Haunt is a triggered ability. "Haunt" on a permanent
			means "When this permanent is put into a graveyard from play,
			remove it from the game haunting target creature." "Haunt" on an
			instant or sorcery spell means "When this spell is put into a
			graveyard during its resolution, remove it from the game
			haunting target creature."
			502.51b Cards that are in the removed-from-the-game zone as the
			result of a haunt ability "haunt" the creature targeted by that
			ability. The phrase "creature it haunts" refers to the object
			targeted by the haunt ability, regardless of whether or not that
			object is still a creature.
			502.51c Triggered abilities of cards with haunt that refer to
			the haunted creature can trigger in the removed-from-the-game
			zone.
		-->
		<ability reference-name="haunting">
			<triggered-ability name="haunt" zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<in-zone zone="play" />
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="graveyard" />
					</destination-test>
				</moved-card>
				<cost>
					<action ref="target-creature" />
				</cost>
				<effects>
					<private-object operation="add" object-name="haunting" object="target-list.last"
						name="haunt" />
					<target-list operation="clear" name="%" />
					<target type="this" />
					<action ref="remove-from-game" />
				</effects>
			</triggered-ability>
		</ability>

		<!-- Graft
			This rule has not been documented yet.
		-->

		<!-- MACRO (value) : Graft (value) -->


		<!-- Bushido
			502.38a Bushido is a triggered ability. "Bushido N" means
			"Whenever this creature blocks or becomes blocked, it gets +N/+N
			until end of turn." (See rule 309, "Declare Blockers Step.")
			502.38b The bushido bonus is calculated only once per combat,
			when the triggered ability resolves. Adding or removing blockers
			later in combat won't change the bonus.
			502.38c If a creature has multiple instances of bushido, each
			triggers separately.
		-->
		<ability reference-name="bushido1-blocked">
			<triggered-ability name="bushido1" zone="play">
				<declared-blocking>
					<attacking-test>
						<is-this />
					</attacking-test>
				</declared-blocking>
				<effects>
					<target type="this" />
					<action ref="add+1+1-until-eot" />
				</effects>
			</triggered-ability>
		</ability>
		<ability reference-name="bushido1-blocking">
			<triggered-ability zone="play">
				<declared-blocking>
					<blocking-test>
						<is-this />
					</blocking-test>
				</declared-blocking>
				<effects>
					<target type="this" />
					<action ref="add+1+1-until-eot" />
				</effects>
			</triggered-ability>
		</ability>

		<ability reference-name="bushido2-blocked">
			<triggered-ability name="bushido2" zone="play">
				<declared-blocking>
					<attacking-test>
						<is-this />
					</attacking-test>
				</declared-blocking>
				<effects>
					<target type="this" />
					<action ref="add+2+2-until-eot" />
				</effects>
			</triggered-ability>
		</ability>
		<ability reference-name="bushido2-blocking">
			<triggered-ability zone="play">
				<declared-blocking>
					<blocking-test>
						<is-this />
					</blocking-test>
				</declared-blocking>
				<effects>
					<target type="this" />
					<action ref="add+2+2-until-eot" />
				</effects>
			</triggered-ability>
		</ability>
		<ability reference-name="bushido3-blocked">
			<triggered-ability name="bushido3" zone="play">
				<declared-blocking>
					<attacking-test>
						<is-this />
					</attacking-test>
				</declared-blocking>
				<effects>
					<target type="this" />
					<action ref="add+3+3-until-eot" />
				</effects>
			</triggered-ability>
		</ability>
		<ability reference-name="bushido3-blocking">
			<triggered-ability zone="play">
				<declared-blocking>
					<blocking-test>
						<is-this />
					</blocking-test>
				</declared-blocking>
				<effects>
					<target type="this" />
					<action ref="add+3+3-until-eot" />
				</effects>
			</triggered-ability>
		</ability>
		<ability reference-name="bushido5-blocked">
			<triggered-ability name="bushido5" zone="play">
				<declared-blocking>
					<attacking-test>
						<is-this />
					</attacking-test>
				</declared-blocking>
				<effects>
					<target type="this" />
					<action ref="add+5+5-until-eot" />
				</effects>
			</triggered-ability>
		</ability>
		<ability reference-name="bushido5-blocking">
			<triggered-ability zone="play">
				<declared-blocking>
					<blocking-test>
						<is-this />
					</blocking-test>
				</declared-blocking>
				<effects>
					<target type="this" />
					<action ref="add+5+5-until-eot" />
				</effects>
			</triggered-ability>
		</ability>

		<ability reference-name="indestructible">
			<replacement-ability zone="play">
				<lethal-damage>
					<test>
						<is-this />
					</test>
				</lethal-damage>
				<effects />
			</replacement-ability>
		</ability>
		<ability reference-name="island-home">
			<triggered-ability name="island-home" zone="play">
				<when>
					<not>
						<has restriction-zone="play">
							<and>
								<controller player="controller" />
								<has-idcard idcard="island" />
							</and>
						</has>
					</not>
				</when>
				<effects>
					<action ref="sacrifice-this" />
				</effects>
			</triggered-ability>
		</ability>
		<ability reference-name="forest-home">
			<triggered-ability name="forest-home" zone="play">
				<when>
					<not>
						<has restriction-zone="play">
							<and>
								<controller player="controller" />
								<has-idcard idcard="forest" />
							</and>
						</has>
					</not>
				</when>
				<effects>
					<action ref="sacrifice-this" />
				</effects>
			</triggered-ability>
		</ability>
		<ability reference-name="island-home-attack">
			<replacement-ability name="declared-attacking" zone="play">
				<declared-attacking>
					<test>
						<and>
							<is-this />
							<not>
								<has restriction-zone="play">
									<and>
										<controller player="opponent" />
										<has-idcard idcard="island" />
									</and>
								</has>
							</not>
						</and>
					</test>
				</declared-attacking>
				<effects />
			</replacement-ability>
		</ability>
		<ability reference-name="swamp-home-attack">
			<replacement-ability name="declared-attacking" zone="play">
				<declared-attacking>
					<test>
						<and>
							<is-this />
							<not>
								<has restriction-zone="play">
									<and>
										<controller player="opponent" />
										<has-idcard idcard="swamp" />
									</and>
								</has>
							</not>
						</and>
					</test>
				</declared-attacking>
				<effects />
			</replacement-ability>
		</ability>
		<ability reference-name="forest-home-attack">
			<replacement-ability name="declared-attacking" zone="play">
				<declared-attacking>
					<test>
						<and>
							<is-this />
							<not>
								<has restriction-zone="play">
									<and>
										<controller player="opponent" />
										<has-idcard idcard="forest" />
									</and>
								</has>
							</not>
						</and>
					</test>
				</declared-attacking>
				<effects />
			</replacement-ability>
		</ability>

		<!-- CUMULATIVE UPKEEP
			502.13a Cumulative upkeep is a triggered ability that imposes an increasing
			cost on a permanent. The phrase "Cumulative upkeep [cost]" means "At the
			beginning of your upkeep, put an age counter on this permanent, then sacrifice
			this permanent unless you pay [cost] for each age counter on it."
			
			502.13b If a permanent has multiple instances of cumulative upkeep, each
			triggers separately. However, the age counters are not linked to any particular
			ability; each cumulative upkeep ability will count the total number of age
			counters on the permanent at the time that ability resolves.
			Example: A creature has two instances of "Cumulative upkeep-Pay 1 life." The
			creature currently has no counters but both cumulative upkeep abilities trigger.
			When the first ability resolves, the controller adds a counter and then chooses
			to pay 1 life. When the second ability resolves, the controller adds another
			counter and then chooses to pay an additional 2 life.
		-->
		<ability reference-name="cumulative-upkeep">
			<triggered-ability resolution="hidden" reference-name="cumulative-upkeep" zone="play">
				<beginning-of-phase phase="upkeep">
					<test>
						<controller player="currentplayer" card="this" />
					</test>
				</beginning-of-phase>
				<effects>
					<target type="this" />
					<add-object object-name="age" />
				</effects>
			</triggered-ability>
		</ability>

		<!-- ECHO
			502.19a Echo is a triggered ability. "Echo" means "At the beginning of your
			upkeep, if this permanent came under your control since the beginning of your
			last upkeep, sacrifice it unless you pay its mana cost."
		-->
		<!--[[apt lang=en|fr @reference-name]] <<MACRO(\[action\])>>
			The echo ability. This reference accept as macro an action to substitute the default pay-mana action.
			| La capacité echo. Cette référence accepte en macro une action de substitution à l'action pay-mana de défaut. -->
		<ability reference-name="echo">
			<triggered-ability zone="play">
				<beginning-of-phase phase="upkeep">
					<test>
						<controller player="currentplayer" card="this" />
					</test>
				</beginning-of-phase>
				<effects>
					<choice cancel="false" name="echo">
						<either>
							<macro>
								<default>
									<pay-mana value="manacost" />
								</default>
							</macro>
						</either>
						<either>
							<action ref="sacrifice-this" />
						</either>
					</choice>
					<unregister-this />
				</effects>
			</triggered-ability>
		</ability>

		<!-- Fading
			502.20a Fading is a keyword that represents two abilities. The
			phrase "Fading [X]" means "This permanent comes into play with
			X fade counters on it" and "At the beginning of your upkeep,
			remove a fade counter from this permanent. If you can't,
			sacrifice the permanent."
		-->
		<ability reference-name="fading">
			<triggered-ability zone="play" name="fading">
				<beginning-of-phase phase="upkeep">
					<test>
						<controller player="currentplayer" card="this" />
					</test>
				</beginning-of-phase>
				<effects>
					<if-then-hop elsehop="7">
						<test ref="has-no-more-fading" />
					</if-then-hop>
					<action ref="sacrifice-this" />
					<unregister-this />
					<hop value="3" />
					<target type="this" />
					<remove-object object-name="fade" />
				</effects>

			</triggered-ability>
		</ability>

		<!-- Vanishing 
			"502.60a Vanishing is a keyword that represents three abilities. "Vanishing N" means "This
			permanent comes into play with N time counters on it," "At the beginning of your upkeep, if
			this permanent has a time counter on it, remove a time counter from it," and "When the last time
			counter is removed from this permanent, sacrifice it."" -->

		<ability reference-name="vanishing">
			<triggered-ability zone="play" name="vanishing">
				<beginning-of-phase phase="upkeep">
					<test>
						<controller player="currentplayer" card="this" />
					</test>
				</beginning-of-phase>
				<effects>
					<target type="this" />
					<remove-object object-name="time" />
					<if-then-hop elsehop="6">
						<test ref="has-no-more-time" />
					</if-then-hop>
					<action ref="sacrifice-this" />
					<unregister-this />
				</effects>
			</triggered-ability>
		</ability>

		<!-- EXTRA TURN : post a 'extra turn' request for the controller of
			card owning this ability (or referencing this ability). -->
		<ability reference-name="extra-turn">
			<replacement-ability name="extra-turn" zone="play">
				<before-phase phase="untap" />
				<effects>
					<action ref="prepare-extra-turn" />
				</effects>
			</replacement-ability>
		</ability>
		<ability reference-name="extra-combat-phase">
			<replacement-ability name="extra-combat-phase" zone="play">
				<end-of-phase phase="main" />
				<effects>
					<next-phase phase-index="precombat-main" />
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!-- SKIP TURN : post a 'skip next turn' request for the controller of
			card owning this ability (or referencing this ability). -->
		<ability reference-name="skip-next-turn">
			<triggered-ability name="skip-turn" resolution="hidden" zone="play">
				<before-phase phase="untap">
					<test>
						<is-this player="controller" />
					</test>
				</before-phase>
				<effects>
					<!-- Skipping a turn must be done exclusively, so we
						use a markup to use this critical resource. -->
					<if-then-hop elsehop="8">
						<test>
							<equal left="0">
								<right register="game.static" index="skipping-turn" />
							</equal>
						</test>
					</if-then-hop>
					<!-- We set the markup -->
					<modify-register register="game.static" index="skipping-turn" operation="set"
						value="1" />
					<if-then-hop elsehop="2">
						<test>
							<or>
								<!-- no extra turn, normal turn chainning :
									The opponent become the next current player -->
								<equal left="0">
									<right register="game.static" index="normal-next-player" />
								</equal>
								<!-- it was an extra turn, an this one was inserted
									before the opponent's turn whom become the
									next current player. '-->
								<equal left="3">
									<right register="game.static" index="normal-next-player" />
								</equal>
							</or>
						</test>
					</if-then-hop>
					<next-current-player player="currentplayer.opponent" />
					<!-- We restore the normal turn chainning -->
					<modify-register register="game.static" index="normal-next-player"
						operation="clear" />
					<!-- Increment the turn ID -->
					<modify-register register="game.static" index="turnid" operation="add"
						value="1" />
					<!-- We unregister this to avoid any further activation -->
					<unregister-this />
					<!-- We unset the markup -->
					<modify-register register="game.static" index="skipping-turn" operation="clear" />
				</effects>
			</triggered-ability>
		</ability>

		<!-- INIT COUNTER REGISTER TO 0 TO THE MOVING CARD IN PLAY -->
		<ability reference-name="init-counter">
			<triggered-ability name="init-counter" resolution="hidden" zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<not>
								<in-zone zone="play" />
							</not>
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="play" />
					</destination-test>
				</moved-card>
				<effects>
					<modify-register register="this" index="free0" operation="clear" />
					<unregister-this />
				</effects>
			</triggered-ability>
		</ability>

		<!-- Reset counter register to 0 at the beginning of this turn -->
		<ability reference-name="reset-counter">
			<triggered-ability zone="play">
				<before-phase phase="untap" />
				<effects>
					<modify-register register="this" index="free0" operation="clear" />
				</effects>
			</triggered-ability>
		</ability>

		<!-- Reset forecast constraint -->
		<ability reference-name="reset-forecast">
			<triggered-ability zone="play">
				<before-phase phase="untap" />
				<effects>
					<modify-register register="this" index="free0" operation="clear" />
				</effects>
			</triggered-ability>
		</ability>

		<!-- When this card come into play, it come into play tapped -->
		<ability reference-name="come-into-play-tapped">
			<replacement-ability name="come-into-play-tapped" zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<not>
								<in-zone zone="play" />
							</not>
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="play" />
					</destination-test>
				</moved-card>
				<effects>
					<target type="this" />
					<move-card destination="playANDtapped" controller="controller" />
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!-- Prevent all damage from the saved card once -->
		<ability reference-name="prevent-all-from-once">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-prevented">
					<source-test>
						<is target="saved" />
					</source-test>
					<destination-test>
						<is-this player="controller" />
					</destination-test>
				</assigned-damage>
				<effects />
			</replacement-ability>
		</ability>

		<!-- Prevent all damage from the saved card -->
		<ability reference-name="prevent-all-from">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-prevented">
					<source-test>
						<is target="saved" />
					</source-test>
					<destination-test>
						<is-this player="controller" />
					</destination-test>
				</assigned-damage>
				<effects />
			</replacement-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents all damages dealt to this card. 
			| Prévient tous les dommages infligés à cette carte.
		-->
		<ability reference-name="prevent-all-on-this">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-prevented">
					<destination-test>
						<is-this card="tested" />
					</destination-test>
				</assigned-damage>
				<effects />
			</replacement-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Prevents all damages dealt to attached card. 
			| Prévient tous les dommages infligés à la carte attachée.
		-->
		<ability reference-name="prevent-all-on-attachedto">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-prevented">
					<destination-test>
						<is target="attachedto" />
					</destination-test>
				</assigned-damage>
				<effects />
			</replacement-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			The saved card deals no combat damage. 
			| La carte sauvegardée n'inflige pas de dégat de combat.
		-->
		<ability reference-name="deals-no-combat-damage">
			<replacement-ability zone="play">
				<assigned-damage type="damage-combat-can-be-prevented">
					<source-test>
						<is target="saved" />
					</source-test>
				</assigned-damage>
				<effects />
			</replacement-ability>
		</ability>

		<!-- PREVENT ONE DAMAGE FROM THE SAVED COMPONENT -->
		<ability reference-name="prevent-1-from-the-saved-one">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-prevented">
					<source-test>
						<is target="saved" />
					</source-test>
					<destination-test>
						<is-this player="controller" />
					</destination-test>
				</assigned-damage>
				<effects>
					<target type="context.target" />
					<assign-damage type="context.int2">
						<value>
							<minus right="1" left="context.int" />
						</value>
					</assign-damage>
					<!-- this shield is removed -->
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!-- PREVENT ALL DAMAGE ON SAVED COMPONENT -->
		<ability reference-name="prevent-all">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-prevented">
					<destination-test>
						<and>
							<in-zone zone="play" />
							<is target="saved" />
						</and>
					</destination-test>
				</assigned-damage>
				<effects>
					<!-- this shield is removed -->
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!-- PREVENT ALL COMBAT DAMAGE ON SAVED COMPONENT -->
		<ability reference-name="prevent-all-combat-on-target">
			<replacement-ability zone="play">
				<assigned-damage type="damage-combat-can-be-prevented">
					<destination-test>
						<and>
							<in-zone zone="play" />
							<is target="saved" />
						</and>
					</destination-test>
				</assigned-damage>
				<effects>
					<!-- this shield is removed -->
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!-- PREVENT ONE DAMAGE ON THE SAVED CARD -->
		<ability reference-name="prevent-1">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-prevented">
					<destination-test>
						<and>
							<in-zone zone="play" />
							<is target="saved" />
						</and>
					</destination-test>
				</assigned-damage>
				<effects>
					<target type="saved" />
					<assign-damage type="context.int2">
						<value>
							<minus right="1" left="context.int" />
						</value>
					</assign-damage>
					<!-- this shield is removed -->
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!-- PREVENT TWO DAMAGE ON THE SAVED CARD -->
		<ability reference-name="prevent-2">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-prevented">
					<destination-test>
						<and>
							<in-zone zone="play" />
							<is target="saved" />
						</and>
					</destination-test>
				</assigned-damage>
				<effects>
					<!-- this shield is removed -->
					<target type="saved" />
					<if-then-hop elsehop="3">
						<test>
							<sup left="context.int" right="1" />
						</test>
					</if-then-hop>
					<assign-damage type="context.int2">
						<value>
							<minus right="2" left="context.int" />
						</value>
					</assign-damage>
					<hop value="2" />
					<action ref="prevent-1" />
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!-- PREVENT 3 DAMAGE ON THE SAVED CARD -->
		<ability reference-name="prevent-3">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-prevented">
					<destination-test>
						<and>
							<in-zone zone="play" />
							<is target="saved" />
						</and>
					</destination-test>
				</assigned-damage>
				<effects>
					<!-- this shield is removed -->
					<target type="saved" />
					<if-then-hop elsehop="3">
						<test>
							<sup left="context.int" right="2" />
						</test>
					</if-then-hop>
					<assign-damage type="context.int2">
						<value>
							<minus right="3" left="context.int" />
						</value>
					</assign-damage>
					<hop value="2" />
					<action ref="prevent-2" />
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!-- PREVENT 4 DAMAGE ON THE SAVED CARD -->
		<ability reference-name="prevent-4">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-prevented">
					<destination-test>
						<and>
							<in-zone zone="play" />
							<is target="saved" />
						</and>
					</destination-test>
				</assigned-damage>
				<effects>
					<!-- this shield is removed -->
					<target type="saved" />
					<if-then-hop elsehop="3">
						<test>
							<sup left="context.int" right="3" />
						</test>
					</if-then-hop>
					<assign-damage type="context.int2">
						<value>
							<minus right="4" left="context.int" />
						</value>
					</assign-damage>
					<hop value="2" />
					<action ref="prevent-3" />
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!-- PREVENT 5 DAMAGE ON THE SAVED CARD -->
		<ability reference-name="prevent-5">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-prevented">
					<destination-test>
						<and>
							<in-zone zone="play" />
							<is target="saved" />
						</and>
					</destination-test>
				</assigned-damage>
				<effects>
					<!-- this shield is removed -->
					<target type="saved" />
					<if-then-hop elsehop="3">
						<test>
							<sup left="context.int" right="4" />
						</test>
					</if-then-hop>
					<assign-damage type="context.int2">
						<value>
							<minus right="5" left="context.int" />
						</value>
					</assign-damage>
					<hop value="2" />
					<action ref="prevent-4" />
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!-- PREVENT 6 DAMAGE ON THE SAVED CARD -->
		<ability reference-name="prevent-6">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-prevented">
					<destination-test>
						<and>
							<in-zone zone="play" />
							<is target="saved" />
						</and>
					</destination-test>
				</assigned-damage>
				<effects>
					<!-- this shield is removed -->
					<target type="saved" />
					<if-then-hop elsehop="3">
						<test>
							<sup left="context.int" right="5" />
						</test>
					</if-then-hop>
					<assign-damage type="context.int2">
						<value>
							<minus right="6" left="context.int" />
						</value>
					</assign-damage>
					<hop value="2" />
					<action ref="prevent-5" />
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!-- PREVENT {X} DAMAGE ON THE SAVED CARD -->
		<ability reference-name="prevent-x">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-prevented">
					<destination-test>
						<and>
							<in-zone zone="play" />
							<is target="saved" />
						</and>
					</destination-test>
				</assigned-damage>
				<effects>
					<if-then-hop elsehop="5">
						<test>
							<sup-equal left="context.int">
								<right register="ability" index="0" />
							</sup-equal>
						</test>
					</if-then-hop>
					<!-- this shield is removed -->
					<target type="saved" />
					<assign-damage type="context.int2">
						<value>
							<minus left="context.int">
								<right register="ability" index="0" />
							</minus>
						</value>
					</assign-damage>
					<unregister-this />
					<hop value="2" />
					<modify-register register="ability" index="0" operation="minus"
						value="context.int" />
				</effects>
			</replacement-ability>
		</ability>

		<!-- REDIRECT {X} DAMAGE FROM SAVED CARD1 to THE SAVED CARD2 -->
		<ability reference-name="redirect-X">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-redirected">
					<destination-test>
						<is target="saved" />
					</destination-test>
				</assigned-damage>
				<effects>
					<if-then-hop elsehop="8">
						<test>
							<sup-equal left="context.int">
								<right register="ability" index="0" />
							</sup-equal>
						</test>
					</if-then-hop>

					<!-- damage to redirect is greater than "0" index -->
					<target type="saved2" />
					<assign-damage type="context.int2">
						<value register="ability" index="0" />
					</assign-damage>
					<target-list operation="clear" />
					<target type="saved" />
					<assign-damage type="context.int2">
						<value>
							<minus left="context.int">
								<right register="ability" index="0" />
							</minus>
						</value>
					</assign-damage>
					<unregister-this />
					<hop value="4" />

					<!-- damage to redirect is lower than register[0] -->
					<target type="saved2" />
					<assign-damage type="context.int2" value="context.int" />
					<modify-register operation="minus" index="0" register="ability"
						value="context.int" />
				</effects>
			</replacement-ability>
		</ability>

		<!-- REDIRECT {all} DAMAGE FROM SAVED CARD1 to THE SAVED CARD2 -->
		<ability reference-name="redirect-1">
			<replacement-ability zone="play">
				<assigned-damage type="damage-can-be-redirected">
					<destination-test>
						<is target="saved" />
					</destination-test>
				</assigned-damage>
				<effects>
					<target type="saved2" />
					<assign-damage type="context.int2" value="context.int" />
				</effects>
			</replacement-ability>
		</ability>

		<!--
			502.50. Bloodthirst:
			502.50a Bloodthirst is a static ability. "Bloodthirst
			N" means "If an opponent was dealt damage this turn,
			this permanent comes into play with N +1/+1 counters on
			it."
		-->
		<!--[[apt lang=en|fr @reference-name]]
			Bloodthirst 1 implementation.
			Example : {{{mtg/cards/Bloodscale\_Prowler.html}Bloodscale Prowler}}
			| Implementation de bloodthirst 1.
			Exemple : {{{mtg/cards/Bloodscale\_Prowler.html}Bloodscale Prowler}}
		-->
		<ability reference-name="bloodthirst1">
			<replacement-ability zone="play" name="bloodthirst-1-">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<not>
								<in-zone zone="play" />
							</not>
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="play" />
					</destination-test>
				</moved-card>
				<effects>
					<target type="this" />
					<if-then-hop elsehop="2">
						<test>
							<sup right="0">
								<left register="opponent" index="damage-dealt-this-turn" />
							</sup>
						</test>
					</if-then-hop>
					<add-object object-name="+1/+1" />
					<action ref="put-in-play" />
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Bloodthirst 2 implementation.
			Example : {{{mtg/cards/Scab\_Clan\_Mauler.html}Scab-Clan Mauler}}
			| Implementation de bloodthirst 2.
			Exemple : {{{mtg/cards/Scab\_Clan\_Mauler.html}Scab-Clan Mauler}}
		-->
		<ability reference-name="bloodthirst2">
			<replacement-ability zone="play" name="bloodthirst-2-">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<not>
								<in-zone zone="play" />
							</not>
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="play" />
					</destination-test>
				</moved-card>
				<effects>
					<target type="this" />
					<if-then-hop elsehop="3">
						<test>
							<sup right="0">
								<left register="opponent" index="damage-dealt-this-turn" />
							</sup>
						</test>
					</if-then-hop>
					<repeat value="2" />
					<add-object object-name="+1/+1" />
					<action ref="put-in-play" />
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Bloodthirst 3 implementation.
			Example : {{{mtg/cards/Ghor\_Clan\_Savage.html}Ghor-Clan Savage}}
			| Implementation de bloodthirst 1.
			Exemple : {{{mtg/cards/Ghor\_Clan\_Savage.html}Ghor-Clan Savage}}
		-->
		<ability reference-name="bloodthirst3">
			<replacement-ability zone="play" name="bloodthirst-3-">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<not>
								<in-zone zone="play" />
							</not>
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="play" />
					</destination-test>
				</moved-card>
				<effects>
					<target type="this" />
					<if-then-hop elsehop="3">
						<test>
							<sup right="0">
								<left register="opponent" index="damage-dealt-this-turn" />
							</sup>
						</test>
					</if-then-hop>
					<repeat value="3" />
					<add-object object-name="+1/+1" />
					<action ref="put-in-play" />
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!--
			502.47. Dredge
			
			502.47a Dredge is a static ability that functions only while the card with
			dredge is in a player's graveyard. "Dredge N" means "As long as you have
			at least N cards in your library, if you would draw a card, you may
			instead put N cards from the top of your library into your graveyard and
			return this card from your graveyard to your hand."
			
			502.47b A player with fewer cards in his or her library than the number
			required by a dredge ability can't put any of them into his or her
			graveyard this way.
		-->
		<!--[[apt lang=en|fr @reference-name]]
			Dredge 1 implementation.
			Example : {{{mtg/cards/Grave\_Shell\_Scarab.html}Grave-Shell Scarab}}
			| Implementation de dredge 1.
			Exemple : {{{mtg/cards/Grave\_Shell\_Scarab.html}Grave-Shell Scarab}}
		-->
		<ability reference-name="dredge1">
			<replacement-ability zone="graveyard" name="dredge-1-">
				<moved-card>
					<source-test>
						<and>
							<action-source name="draw-%n-card" />
							<controller player="you" />
							<has restriction-zone="library">
								<controller player="you" />
							</has>
						</and>
					</source-test>
				</moved-card>
				<effects>
					<choice cancel="false">
						<either>
							<target type="you" />
							<action ref="draw-a-card" />
						</either>
						<either>
							<target type="you" />
							<move-player-card from="library" to="graveyard" controller="owner" />
							<target type="this" />
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</replacement-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Dredge 2 implementation.
			| Implementation de dredge 2.
		-->
		<ability reference-name="dredge2">
			<replacement-ability zone="graveyard" name="dredge-2-">
				<moved-card>
					<source-test>
						<and>
							<action-source name="draw-%n-card" />
							<controller player="you" />
							<sup-equal right="2">
								<left>
									<counter restriction-zone="library">
										<controller player="you" />
									</counter>
								</left>
							</sup-equal>
						</and>
					</source-test>
				</moved-card>
				<effects>
					<choice cancel="false">
						<either>
							<target type="you" />
							<action ref="draw-a-card" />
						</either>
						<either>
							<target type="you" />
							<repeat value="2" />
							<move-player-card from="library" to="graveyard" controller="owner" />
							<target type="this" />
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</replacement-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Dredge 3 implementation.
			Example : {{{mtg/cards/Darkblast.html}Darkblast}}
			| Implementation de dredge 3.
			Exemple : {{{mtg/cards/Darkblast.html}Darkblast}}
		-->
		<ability reference-name="dredge3">
			<replacement-ability zone="graveyard" name="dredge-3-">
				<moved-card>
					<source-test>
						<and>
							<action-source name="draw-%n-card" />
							<controller player="you" />
							<sup-equal right="3">
								<left>
									<counter restriction-zone="library">
										<controller player="you" />
									</counter>
								</left>
							</sup-equal>
						</and>
					</source-test>
				</moved-card>
				<effects>
					<choice cancel="false">
						<either>
							<target type="you" />
							<action ref="draw-a-card" />
						</either>
						<either>
							<target type="you" />
							<repeat value="3" />
							<move-player-card from="library" to="graveyard" controller="owner" />
							<target type="this" />
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</replacement-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Dredge 5 implementation.
			| Implementation de dredge 5.
		-->
		<ability reference-name="dredge4">
			<replacement-ability zone="graveyard" name="dredge-4-">
				<moved-card>
					<source-test>
						<and>
							<action-source name="draw-%n-card" />
							<controller player="you" />
							<sup-equal right="4">
								<left>
									<counter restriction-zone="library">
										<controller player="you" />
									</counter>
								</left>
							</sup-equal>
						</and>
					</source-test>
				</moved-card>
				<effects>
					<choice cancel="false">
						<either>
							<target type="you" />
							<action ref="draw-a-card" />
						</either>
						<either>
							<target type="you" />
							<repeat value="4" />
							<move-player-card from="library" to="graveyard" controller="owner" />
							<target type="this" />
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</replacement-ability>
		</ability>
		
		<!--[[apt lang=en|fr @reference-name]]
			Dredge 5 implementation.
			| Implementation de dredge 5.
		-->
		<ability reference-name="dredge5">
			<replacement-ability zone="graveyard" name="dredge-5-">
				<moved-card>
					<source-test>
						<and>
							<action-source name="draw-%n-card" />
							<controller player="you" />
							<sup-equal right="5">
								<left>
									<counter restriction-zone="library">
										<controller player="you" />
									</counter>
								</left>
							</sup-equal>
						</and>
					</source-test>
				</moved-card>
				<effects>
					<choice cancel="false">
						<either>
							<target type="you" />
							<action ref="draw-a-card" />
						</either>
						<either>
							<target type="you" />
							<repeat value="5" />
							<move-player-card from="library" to="graveyard" controller="owner" />
							<target type="this" />
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</replacement-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Dredge 6 implementation.
			| Implementation de dredge 6.
		-->
		<ability reference-name="dredge6">
			<replacement-ability zone="graveyard" name="dredge-6-">
				<moved-card>
					<source-test>
						<and>
							<action-source name="draw-%n-card" />
							<controller player="you" />
							<sup-equal right="6">
								<left>
									<counter restriction-zone="library">
										<controller player="you" />
									</counter>
								</left>
							</sup-equal>
						</and>
					</source-test>
				</moved-card>
				<effects>
					<choice cancel="false">
						<either>
							<target type="you" />
							<action ref="draw-a-card" />
						</either>
						<either>
							<target type="you" />
							<repeat value="6" />
							<move-player-card from="library" to="graveyard" controller="owner" />
							<target type="this" />
							<action ref="return-to-hand" />
						</either>
					</choice>
				</effects>
			</replacement-ability>
		</ability>

		<!-- 
			502.48. Transmute
			
			502.48a Transmute is an activated ability that functions only while the 
			card with transmute is in a player's hand. "Transmute [cost]" means 
			"[Cost], Discard this card: Search your library for a card with the same 
			converted mana cost as the discarded card, reveal that card, and put it 
			into your hand. Then shuffle your library. Play this ability only any time 
			you could play a sorcery."
			
			502.48b Although the transmute ability is playable only if the card is in 
			a player's hand, it continues to exist while the object is in play and in 
			all other zones. Therefore objects with transmute will be affected by 
			effects that depend on objects having one or more activated abilities.
		-->
		<!--[[apt lang=en|fr @reference-name]]
			Transmute implementation.
			Example : {{{mtg/cards/Perplex.html}Perplex}}
			| Implementation de transmute.
			Exemple : {{{mtg/cards/Perplex.html}Perplex}}
		-->
		<ability reference-name="transmute">
			<activated-ability playable="sorcery" zone="hand" play-as-spell="false"
				name="transmute">
				<cost>
					<macro>
						<default />
					</macro>
					<target type="this" />
					<action ref="discard-cards" name="%" />
				</cost>
				<effects>
					<action ref="search-lib" name="transmute">
						<test>
							<equal>
								<right register="tested" index="manacost" />
								<left register="this" index="manacost" />
							</equal>
						</test>
					</action>
					<action ref="return-to-hand" name="%" />
				</effects>
			</activated-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Rampage 1 implementation.
			Example : {{{mtg/cards/Balduvian\_War\_Makers.html}Balduvian War-Makers}}
			| Implementation de Sauvagerie 1.
			Exemple : {{{mtg/cards/Balduvian\_War\_Makers.html}Balduvian War-Makers}}
		-->
		<ability reference-name="rampage1">
			<triggered-ability zone="play" resolution="normal" name="rampage-1-">
				<end-of-phase phase="declare-blocking">
					<test>
						<and>
							<test ref="is-attacking" />
							<test ref="is-blocked" />
						</and>
					</test>
				</end-of-phase>
				<effects>
					<action ref="priv_prepare-rampage" />
					<action ref="priv_do-rampage" value="1" />
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Rampage 2 implementation.
			Example : {{{mtg/cards/Balduvian\_War\_Makers.html}Balduvian War-Makers}}
			| Implementation de Sauvagerie 2.
			Exemple : {{{mtg/cards/Balduvian\_War\_Makers.html}Balduvian War-Makers}}
		-->
		<ability reference-name="rampage2">
			<triggered-ability zone="play" resolution="normal" name="rampage-2-">
				<end-of-phase phase="declare-blocking">
					<test>
						<and>
							<test ref="is-attacking" />
							<test ref="is-blocked" />
						</and>
					</test>
				</end-of-phase>
				<effects>
					<action ref="priv_prepare-rampage" />
					<action ref="priv_do-rampage" value="2" />
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Rampage 3 implementation.
			Example : {{{mtg/cards/Craw\_Giant.html}Craw Giant}}
			| Implementation de Sauvagerie 3.
			Exemple : {{{mtg/cards/Craw\_Giant.html}Craw Giant}}
		-->
		<ability reference-name="rampage3">
			<triggered-ability zone="play" resolution="normal" name="rampage-3-">
				<end-of-phase phase="declare-blocking">
					<test>
						<and>
							<test ref="is-attacking" />
							<test ref="is-blocked" />
						</and>
					</test>
				</end-of-phase>
				<effects>
					<action ref="priv_prepare-rampage" />
					<action ref="priv_do-rampage" value="3" />
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Rampage 4 implementation.
			Example : {{{mtg/cards/Teekas\_Dragon.html}Teeka's Dragon}}
			| Implementation de Sauvagerie 4.
			Exemple : {{{mtg/cards/Teekas\_Dragon.html}Teeka's Dragon}}
		-->
		<ability reference-name="rampage4">
			<triggered-ability zone="play" resolution="normal" name="rampage-4-">
				<end-of-phase phase="declare-blocking">
					<test>
						<and>
							<test ref="is-attacking" />
							<test ref="is-blocked" />
						</and>
					</test>
				</end-of-phase>
				<effects>
					<action ref="priv_prepare-rampage" />
					<action ref="priv_do-rampage" value="4" />
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			At end of turn, sacrifice this card.
			Example : {{{mtg/cards/Dragon\_Whelp.html}Dragon Whelp}}
			| A la fin du tour, sacrifier cette carte.
			Exemple : {{{mtg/cards/Dragon\_Whelp.html}Dragon Whelp}}
		-->
		<ability reference-name="eot-sacrifice">
			<triggered-ability zone="play">
				<end-of-phase phase="eot" />
				<effects>
					<action ref="sacrifice-this" />
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Regenerate the saved card if possible. This ability should appear 
			directly within the card abilities but used with create-ability action.
			| Regénérère si possible la carte sauvegardée. Cette capacité ne devrait pas apparaître
			directement dans les capacités d'une carte, mais utilisée avec l'action
			create-ability.
		-->
		<ability reference-name="regenerate">
			<replacement-ability zone="play">
				<lethal-damage>
					<test>
						<and>
							<is target="saved" />
							<test ref="can-regenerate" />
						</and>
					</test>
				</lethal-damage>
				<effects>
					<target type="context.card" />
					<tap />
					<action ref="remove-from-combat" />
					<action ref="remove-all-damage" />
					<unregister-this />
				</effects>
			</replacement-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Whenever a creature comes into play, THIS becomes a copy of 
			that creature and gains this ability.
			Example : {{{mtg/cards/Unstable\_Shapeshifter.html}Unstable Shapeshifter}}
			| Lorsqu'une créature arrive en jeu, THIS 
			devient une copie de cette carte et gagne cette capacité.
			Exemple : {{{mtg/cards/Unstable\_Shapeshifter.html}Unstable Shapeshifter}}
		-->
		<ability reference-name="shapeshifter-ability">
			<triggered-ability zone='play'>
				<moved-card>
					<source-test>
						<and>
							<not>
								<is-this />
							</not>
							<not>
								<in-zone zone='play' card='tested' />
							</not>
						</and>
					</source-test>
					<destination-test>
						<and>
							<in-zone zone='play' card='tested' />
							<has-idcard idcard="creature" />
						</and>
					</destination-test>
				</moved-card>
				<effects>
					<copy-card card="context.card" to="this" />
					<add-ability ref="this" />
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en @reference-name]]
			whenever THIS (context creature) deals damage, you gain that much life.
			Example: Kjeldoran Gargoyle, Exalted Angel
		-->
		<ability reference-name="lifelink">
			<triggered-ability zone="play">
				<assigned-damage type="damage-any">
					<source-test>
						<is-this />
					</source-test>
				</assigned-damage>
				<effects>
					<action ref="gain-life" value="context.int" />
				</effects>
			</triggered-ability>
		</ability>
		
		<!--[[apt lang=en @reference-name]]
			whenever THIS (context creature) deals damage to a creature, destroy that creature.
			Example: Moonglove Winnower
		-->
		<ability reference-name="deathtouch">
			<triggered-ability zone='play'>
				<assigned-damage type='damage-any'>
					<source-test>
						<is-this/>
					</source-test>
					<destination-test>
						<and>
							<not>
								<is-player/>
							</not>
							<has-idcard idcard='creature'/>
						</and>
					</destination-test>
				</assigned-damage>
				<effects>
					<target type="context.card"/>
					<action ref="destroy"/>
				</effects>
			</triggered-ability>
		</ability>
		
		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : to put in play a permanent, paying it's manacost and a kicker. 
			This macro works only for single paid kicker. There are two 
			<<<\<actions\>>>> nodes for this macro, respectivly corresponding to the 
			kicker's cost and the associated effect.
			| \{T\} : mettre en jeu un permanent en payant son coût de mana ainsi 
			qu'un kicker. Cette macro ne fonctionne qu'avec un seul kicker payé. 
			Il y a deux noeuds <<<\<actions\>>>> correspondants respectivement au coût 
			du kick et à son effet associé. -->
		<ability reference-name="cast-spell-kicker">
			<activated-ability playable="this" zone="hand">
				<cost>
					<pay-mana value="manacost" />
					<action ref="kicker" />
					<macro><!-- Kicker cost -->
						<default />
					</macro>
				</cost>
				<effects>
					<action ref="put-in-play" />
					<macro><!-- Kicker effect -->
						<default />
					</macro>
				</effects>
			</activated-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : to put in play a permanent, paying it's manacost and the second kicker. 
			This macro works only for single paid kicker. There are two 
			<<<\<actions\>>>> nodes for this macro, respectivly corresponding to the 
			kicker's cost and the associated effect.
			| \{T\} : mettre en jeu un permanent en payant son coût de mana ainsi 
			que le second kicker. Cette macro ne fonctionne qu'avec un seul kicker payé. 
			Il y a deux noeuds <<<\<actions\>>>> correspondants respectivement au coût 
			du kick et à son effet associé. -->
		<ability reference-name="cast-spell-kicker2">
			<activated-ability playable="this" zone="hand">
				<cost>
					<pay-mana value="manacost" />
					<action ref="kicker2" />
					<macro><!-- Kicker cost -->
						<default />
					</macro>
				</cost>
				<effects>
					<action ref="put-in-play" />
					<macro><!-- Kicker effect -->
						<default />
					</macro>
				</effects>
			</activated-ability>
		</ability>


		<!--[[apt lang=en|fr @reference-name]]
			\{T\} : to put in play a permanent, paying it's manacost and the first and second kicker. 
			This macro works only for two paid kickers. There are four
			<<<\<actions\>>>> nodes for this macro, respectivly corresponding to the 
			first, then the second kicker's cost and the associated effect of respectivly first and second kicker.
			| \{T\} : mettre en jeu un permanent en payant son coût de mana ainsi 
			que le premier et le second kicker. Cette macro ne fonctionne qu'avec deux kicks payé. 
			Il y a quatre noeuds <<<\<actions\>>>> correspondants respectivement au coût 
			du premier et du second kick et à respectivement au premier et au deuxième effet associé. -->
		<ability reference-name="cast-spell-kicker12">
			<activated-ability playable="this" zone="hand">
				<cost>
					<pay-mana value="manacost" />
					<action ref="kicker" />
					<macro><!-- Kicker cost -->
						<default />
					</macro>
					<action ref="kicker2" />
					<macro><!-- Kicker2 cost -->
						<default />
					</macro>
				</cost>
				<effects>
					<action ref="put-in-play" />
					<macro><!-- Kicker effect -->
						<default />
					</macro>
					<macro><!-- Kicker2 effect -->
						<default />
					</macro>
				</effects>
			</activated-ability>
		</ability>

		<!--
			502.27. Amplify
			502.27a Amplify is a static ability. "Amplify N" means "As this 
			object comes into play, reveal any number of cards from your hand 
			that share a creature type with it. This permanent comes into play 
			with N +1/+1 counters on it for each card revealed this way. You 
			can't reveal this card or any other cards that are coming into 
			play at the same time as this card."
		-->
		
		<!--[[apt lang=en|fr @reference-name]]
			Amplify 1 ability.
			Example : {{{mtg/cards/Daru\_Stinger.html}Daru Stinger}}
			| Capacité amplify 1.
			Exemple : {{{mtg/cards/Daru\_Stinger.html}Daru Stinger}}
		-->
		<ability reference-name="amplify-1">
			<triggered-ability name="amplify" resolution="normal" zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<not>
								<in-zone zone="play" />
							</not>
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="play" />
					</destination-test>
				</moved-card>
				<effects>
					<action ref="amplify" value="1" />
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Amplify 2 ability.
			Example : {{{mtg/cards/Daru\_Stinger.html}Daru Stinger}}
			| Capacité amplify 2.
			Exemple : {{{mtg/cards/Daru\_Stinger.html}Daru Stinger}}
		-->
		<ability reference-name="amplify-2">
			<triggered-ability name="amplify" resolution="normal" zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<not>
								<in-zone zone="play" />
							</not>
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="play" />
					</destination-test>
				</moved-card>
				<effects>
					<action ref="amplify" value="2" />
				</effects>
			</triggered-ability>
		</ability>

		<!--[[apt lang=en|fr @reference-name]]
			Amplify 3 ability.
			Example : {{{mtg/cards/Daru\_Stinger.html}Daru Stinger}}
			| Capacité amplify 3.
			Exemple : {{{mtg/cards/Daru\_Stinger.html}Daru Stinger}}
		-->
		<ability reference-name="amplify-3">
			<triggered-ability name="amplify" resolution="normal" zone="play">
				<moved-card>
					<source-test>
						<and>
							<is-this />
							<not>
								<in-zone zone="play" />
							</not>
						</and>
					</source-test>
					<destination-test>
						<in-zone zone="play" />
					</destination-test>
				</moved-card>
				<effects>
					<action ref="amplify" value="3" />
				</effects>
			</triggered-ability>
		</ability>
	</abilities>

	<!--[[apt lang=en]]
		** Attachment references
		
		`These are described within the nested <<<\<attachments\>>>> element. We can find
		`the following references :
		
		*___________________________+__________________________________________________+
		| <<Reference name>>        | <<Description>>
		*___________________________+__________________________________________________+-->
	<!--[[apt lang=fr]]
		** Les références d'attaches
		
		`Elles sont décrites au sein de l'élément <<<\<attachments\>>>>. On peut
		`trouver les références suivantes :
		
		*___________________________+__________________________________________________+
		| <<Nom de la référence>>   | <<Description>>
		*___________________________+__________________________________________________+-->

	<attachments>

		<!--[[apt lang=en|fr @reference-name]]
			Use this reference to attach '<enchant: creature>' <auras> to a
			valid creature to enchant.
			| Utilisez cette référence pour attacher une <aura> de type
			'<enchanter : créature>' à une créature valide à enchanter. -->
		<attachment reference-name="enchant-creature">
			<modifiers />
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="enchant-land">
			<modifiers />
			<valid-target ref="valid-land-to-enchant" />
			<valid-attachment ref="valid-enchant-land" />
		</attachment>
		<attachment reference-name="enchant-non-wall">
			<modifiers />
			<valid-target>
				<and>
					<test ref="valid-creature-to-enchant" />
					<has-property property="wall" card="tested" />
				</and>
			</valid-target>
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="enchant-artifact">
			<modifiers />
			<valid-target ref="valid-artifact-to-enchant" />
			<valid-attachment ref="valid-enchant-artifact" />
		</attachment>
		<attachment reference-name="enchant-artifact-creature">
			<modifiers />
			<valid-target ref="valid-artifact-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-artifact-creature" />
		</attachment>
		<attachment reference-name="enchant">
			<modifiers />
			<valid-target ref="valid-to-enchant" />
			<valid-attachment ref="valid-enchant" />
		</attachment>
		<attachment reference-name="enchant-permanent">
			<modifiers />
			<valid-target ref="valid-permanent-to-enchant" />
			<valid-attachment ref="valid-enchant" />
		</attachment>
		<attachment reference-name="-2/-1">
			<modifiers>
				<register-modifier index="power" value="2" operation="minus" linked="true" />
				<register-modifier index="toughness" value="1" operation="minus" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="-1/-1">
			<modifiers>
				<register-modifier index="power" value="1" operation="minus" linked="true" />
				<register-modifier index="toughness" value="1" operation="minus" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="-2/-2">
			<modifiers>
				<register-modifier index="power" value="2" operation="minus" linked="true" />
				<register-modifier index="toughness" value="2" operation="minus" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+2/-2">
			<modifiers>
				<register-modifier index="power" value="2" operation="add" linked="true" />
				<register-modifier index="toughness" value="2" operation="minus" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="-2/-0">
			<modifiers>
				<register-modifier index="power" value="2" operation="minus" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="-3/-0">
			<modifiers>
				<register-modifier index="power" value="3" operation="minus" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+0/+2">
			<modifiers>
				<register-modifier index="toughness" value="2" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+1/+2">
			<modifiers>
				<register-modifier index="power" value="1" operation="add" linked="true" />
				<register-modifier index="toughness" value="2" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+1/+5">
			<modifiers>
				<register-modifier index="power" value="1" operation="add" linked="true" />
				<register-modifier index="toughness" value="5" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+2/+1">
			<modifiers>
				<register-modifier index="power" value="2" operation="add" linked="true" />
				<register-modifier index="toughness" value="1" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+1/+1">
			<modifiers>
				<register-modifier index="power" value="1" operation="add" linked="true" />
				<register-modifier index="toughness" value="1" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+2/+2">
			<modifiers>
				<register-modifier index="power" value="2" operation="add" linked="true" />
				<register-modifier index="toughness" value="2" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+3/+3">
			<modifiers>
				<register-modifier index="power" value="3" operation="add" linked="true" />
				<register-modifier index="toughness" value="3" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+5/+5">
			<modifiers>
				<register-modifier index="power" value="5" operation="add" linked="true" />
				<register-modifier index="toughness" value="5" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+2/+5">
			<modifiers>
				<register-modifier index="power" value="2" operation="add" linked="true" />
				<register-modifier index="toughness" value="5" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+1/+3">
			<modifiers>
				<register-modifier index="power" value="1" operation="add" linked="true" />
				<register-modifier index="toughness" value="3" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+3/+1">
			<modifiers>
				<register-modifier index="power" value="3" operation="add" linked="true" />
				<register-modifier index="toughness" value="1" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+4/+0">
			<modifiers>
				<register-modifier index="power" value="4" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+1/+0">
			<modifiers>
				<register-modifier index="power" value="1" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="+2/+0">
			<modifiers>
				<register-modifier index="power" value="2" operation="add" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="control">
			<modifiers>
				<controller-modifier player="you" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="control-permanent">
			<modifiers>
				<controller-modifier player="you" linked="true" />
			</modifiers>
			<valid-target ref="valid-permanent-to-enchant" />
			<valid-attachment ref="valid-enchant" />
		</attachment>
		<attachment reference-name="control-land">
			<modifiers>
				<controller-modifier player="you" linked="true" />
			</modifiers>
			<valid-target ref="valid-land-to-enchant" />
			<valid-attachment ref="valid-enchant-land" />
		</attachment>
		<attachment reference-name="control-artifact">
			<modifiers>
				<controller-modifier player="you" linked="true" />
			</modifiers>
			<valid-target ref="valid-artifact-to-enchant" />
			<valid-attachment ref="valid-enchant-artifact" />
		</attachment>
		<attachment reference-name="control-artifact-creature">
			<modifiers>
				<controller-modifier player="you" linked="true" />
			</modifiers>
			<valid-target ref="valid-artifact-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-artifact-creature" />
		</attachment>
		<attachment reference-name="protection-from-black">
			<modifiers>
				<property-modifier property="protection-from-black" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="protection-from-blue">
			<modifiers>
				<property-modifier property="protection-from-blue" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="protection-from-green">
			<modifiers>
				<property-modifier property="protection-from-green" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="protection-from-red">
			<modifiers>
				<property-modifier property="protection-from-red" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="protection-from-white">
			<modifiers>
				<property-modifier property="protection-from-white" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="mountainwalk">
			<modifiers>
				<property-modifier property="mountainwalk" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="cannot-be-enchanted">
			<modifiers>
				<property-modifier property="cannot-be-enchanted" linked="true" />
			</modifiers>
			<valid-target ref="valid-land-to-enchant" />
			<valid-attachment ref="valid-enchant-land" />
		</attachment>
		<attachment reference-name="wall-can-attack">
			<modifiers>
				<property-modifier property="wall-can-attack" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="flying">
			<modifiers>
				<property-modifier property="flying" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="trample">
			<modifiers>
				<property-modifier property="trample" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="vigilance">
			<modifiers>
				<property-modifier property="vigilance" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="first-strike">
			<modifiers>
				<property-modifier property="first-strike" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="double-strike">
			<modifiers>
				<property-modifier property="double-strike" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="fear">
			<modifiers>
				<property-modifier property="fear" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="does-not-untap">
			<modifiers>
				<property-modifier property="does-not-untap" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="haste">
			<modifiers>
				<property-modifier property="haste" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="shroud">
			<modifiers>
				<property-modifier property="shroud" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="reach">
			<modifiers>
				<property-modifier property="reach" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="cannot-attack">
			<modifiers>
				<property-modifier property="cannot-attack" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="cannot-block">
			<modifiers>
				<property-modifier property="cannot-block" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="cannot-attack-or-block">
			<modifiers>
				<property-modifier property="cannot-block" linked="true" />
				<property-modifier property="cannot-attack" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="swampwalk">
			<modifiers>
				<property-modifier property="swampwalk" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="banding">
			<modifiers>
				<property-modifier property="banding" linked="true" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="cannot-be-blocked-by-walls">
			<modifiers>
				<property-modifier linked="true" property="cannot-be-blocked-by-walls" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
		<attachment reference-name="unblockable">
			<modifiers>
				<property-modifier linked="true" property="unblockable" />
			</modifiers>
			<valid-target ref="valid-creature-to-enchant" />
			<valid-attachment ref="valid-enchant-creature" />
		</attachment>
	</attachments>
</references>